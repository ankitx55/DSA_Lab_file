\documentclass[12pt,a4paper]{article}
\usepackage{listings}
\usepackage[most]{tcolorbox}
\usepackage{xcolor}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{titlesec}
\titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}

\definecolor{cream}{RGB}{255, 253, 208}

\lstset{
  language=C,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{green!60!black},
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  numbersep=5pt,
  backgroundcolor=\color{white},
  frame=single,
  breaklines=true,
  tabsize=2,
  showstringspaces=false
}

\tcbset{terminalstyle/.style={
    colback=cream!90!white,
    coltext=black,
    fonttitle=\bfseries,
    boxrule=0.5pt,
    arc=4pt,
    outer arc=4pt,
    boxsep=4pt,
    left=6pt,
    right=6pt,
    top=4pt,
    bottom=4pt
}}

\begin{document}

\title{\textbf{Lab Manual}\\Data Structures in C}
\author{Ankit Kumar}
\date{\today}
\maketitle
\newpage
\section*{Experiment 1: Array Operations (Insert, Delete, Search, Sort, Display)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>

#define MAX 100

void insert(int arr[], int n, int pos, int val) {
    if (n >= MAX || pos < 0 || pos > n) {
        printf("Insertion not possible.\n");
        return;
    }
    for (int i = n; i > pos; i--) {
        arr[i] = arr[i - 1];
    }
    arr[pos] = val;
    n++;
    printf("After insertion: ");
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

void delete(int arr[], int n, int pos) {
    if (n <= 0 || pos < 0 || pos >= n) {
        printf("Deletion not possible.\n");
        return;
    }
    for (int i = pos; i < n - 1; i++) {
        arr[i] = arr[i + 1];
    }
    n--;
    printf("After deletion: ");
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

void search(int arr[], int n, int key) {
    int found = 0;
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) {
            printf("Element found at index %d\n", i);
            found = 1;
            break;
        }
    }
    if (!found)
        printf("Element not found.\n");
}

void sort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    printf("Sorted array: ");
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

void display(int arr[], int n) {
    printf("Array: ");
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int arr[MAX], n, choice, val, pos, key;
    printf("Enter number of elements: ");
    scanf("%d", &n);
    printf("Enter %d elements:\n", n);
    for (int i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    do {
        printf("\n--- MENU ---\n");
        printf("1. Insert\n2. Delete\n3. Search\n4. Sort\n5. Display\n6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter position (0 to %d): ", n);
                scanf("%d", &pos);
                printf("Enter value to insert: ");
                scanf("%d", &val);
                insert(arr, n, pos, val);
                break;
            case 2:
                printf("Enter position to delete (0 to %d): ", n - 1);
                scanf("%d", &pos);
                delete(arr, n, pos);
                break;
            case 3:
                printf("Enter value to search: ");
                scanf("%d", &key);
                search(arr, n, key);
                break;
            case 4:
                sort(arr, n);
                break;
            case 5:
                display(arr, n);
                break;
            case 6:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice.\n");
        }
    } while (choice != 6);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{Enter number of elements: 5 \\
Enter 5 elements: \\
10 20 30 40 50 \\
\\
--- MENU --- \\
1. Insert\\2. Delete\\3. Search\\4. Sort\\5. Display\\6. Exit\\
Enter your choice: 1\\
Enter position (0 to 5): 2\\
Enter value to insert: 25\\
After insertion: 10 20 25 30 40 50 \\
\\
--- MENU --- \\
Enter your choice: 2\\
Enter position to delete (0 to 5): 3\\
After deletion: 10 20 25 40 50 \\
\\
--- MENU --- \\
Enter your choice: 3\\
Enter value to search: 40\\
Element found at index 3 \\
\\
--- MENU --- \\
Enter your choice: 4\\
Sorted array: 10 20 25 40 50 \\
\\
--- MENU --- \\
Enter your choice: 5\\
Array: 10 20 25 40 50 \\
\\
--- MENU --- \\
Enter your choice: 6\\
Exiting...}
\end{tcolorbox}

\newpage
\section*{Experiment 2: Matrix Row and Column Operations}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>

#define MAX_ROWS 10
#define MAX_COLS 10

void display(int arr[MAX_ROWS][MAX_COLS], int rows, int cols) {
    printf("Matrix:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d\t", arr[i][j]);
        }
        printf("\n");
    }
}

void insertRow(int arr[MAX_ROWS][MAX_COLS], int *rows, int cols, int pos) {
    if (*rows >= MAX_ROWS || pos < 0 || pos > *rows) {
        printf("Insertion not possible.\n");
        return;
    }
    for (int i = *rows; i > pos; i--) {
        for (int j = 0; j < cols; j++) {
            arr[i][j] = arr[i - 1][j];
        }
    }
    printf("Enter elements of new row:\n");
    for (int j = 0; j < cols; j++) {
        scanf("%d", &arr[pos][j]);
    }
    (*rows)++;
    printf("Row inserted.\n");
}

void deleteRow(int arr[MAX_ROWS][MAX_COLS], int *rows, int cols, int pos) {
    if (*rows <= 0 || pos < 0 || pos >= *rows) {
        printf("Deletion not possible.\n");
        return;
    }
    for (int i = pos; i < *rows - 1; i++) {
        for (int j = 0; j < cols; j++) {
            arr[i][j] = arr[i + 1][j];
        }
    }
    (*rows)--;
    printf("Row deleted.\n");
}

void insertColumn(int arr[MAX_ROWS][MAX_COLS], int rows, int *cols, int pos) {
    if (*cols >= MAX_COLS || pos < 0 || pos > *cols) {
        printf("Insertion not possible.\n");
        return;
    }
    for (int i = 0; i < rows; i++) {
        for (int j = *cols; j > pos; j--) {
            arr[i][j] = arr[i][j - 1];
        }
    }
    printf("Enter elements of new column:\n");
    for (int i = 0; i < rows; i++) {
        scanf("%d", &arr[i][pos]);
    }
    (*cols)++;
    printf("Column inserted.\n");
}

void deleteColumn(int arr[MAX_ROWS][MAX_COLS], int rows, int *cols, int pos) {
    if (*cols <= 0 || pos < 0 || pos >= *cols) {
        printf("Deletion not possible.\n");
        return;
    }
    for (int i = 0; i < rows; i++) {
        for (int j = pos; j < *cols - 1; j++) {
            arr[i][j] = arr[i][j + 1];
        }
    }
    (*cols)--;
    printf("Column deleted.\n");
}

int main() {
    int arr[MAX_ROWS][MAX_COLS], rows, cols, choice, pos;

    printf("Enter number of rows and columns: ");
    scanf("%d %d", &rows, &cols);

    printf("Enter elements of matrix:\n");
    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            scanf("%d", &arr[i][j]);

    do {
        printf("\n--- MENU ---\n");
        printf("1. Insert Row\n2. Delete Row\n3. Insert Column\n4. Delete Column\n5. Display\n6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter row position to insert (0 to %d): ", rows);
                scanf("%d", &pos);
                insertRow(arr, &rows, cols, pos);
                break;
            case 2:
                printf("Enter row position to delete (0 to %d): ", rows - 1);
                scanf("%d", &pos);
                deleteRow(arr, &rows, cols, pos);
                break;
            case 3:
                printf("Enter column position to insert (0 to %d): ", cols);
                scanf("%d", &pos);
                insertColumn(arr, rows, &cols, pos);
                break;
            case 4:
                printf("Enter column position to delete (0 to %d): ", cols - 1);
                scanf("%d", &pos);
                deleteColumn(arr, rows, &cols, pos);
                break;
            case 5:
                display(arr, rows, cols);
                break;
            case 6:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice.\n");
        }

    } while (choice != 6);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{Enter number of rows and columns: 2 3 \\
Enter elements of matrix: \\
1 2 3 \\
4 5 6 \\
\\
--- MENU --- \\
1. Insert Row\\2. Delete Row\\3. Insert Column\\4. Delete Column\\5. Display\\6. Exit \\
Enter your choice: 1\\
Enter row position to insert (0 to 2): 1 \\
Enter elements of new row: \\
7 8 9\\
Row inserted. \\
\\
--- MENU --- \\
Enter your choice: 3 \\
Enter column position to insert (0 to 3): 2 \\
Enter elements of new column: \\
10 11 12\\
Column inserted. \\
\\
--- MENU --- \\
Enter your choice: 5 \\
Matrix: \\
1	2	10	3 \\
7	8	11	9 \\
4	5	12	6 \\
\\
--- MENU --- \\
Enter your choice: 6 \\
Exiting...}
\end{tcolorbox}

\newpage
\section*{Experiment 3: Gauss-Jordan Method for Solving Linear Equations}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>

#define SIZE 10

void gaussJordan(float matrix[SIZE][SIZE], int n) {
    int i, j, k;
    float ratio;

    for (i = 0; i < n; i++) {
        // Make the diagonal element 1
        float diag = matrix[i][i];
        if (diag == 0) {
            printf("Mathematical Error: Division by 0\n");
            return;
        }

        for (j = 0; j <= n; j++) {
            matrix[i][j] = matrix[i][j] / diag;
        }

        // Make other elements in column 0
        for (k = 0; k < n; k++) {
            if (k != i) {
                ratio = matrix[k][i];
                for (j = 0; j <= n; j++) {
                    matrix[k][j] = matrix[k][j] - ratio * matrix[i][j];
                }
            }
        }
    }

    printf("\nSolution:\n");
    for (i = 0; i < n; i++) {
        printf("x%d = %.3f\n", i + 1, matrix[i][n]);
    }
}

int main() {
    float matrix[SIZE][SIZE];
    int n, i, j;

    printf("Enter number of variables: ");
    scanf("%d", &n);

    printf("Enter augmented matrix coefficients (Ax = b):\n");
    for (i = 0; i < n; i++) {
        for (j = 0; j <= n; j++) {
            printf("matrix[%d][%d]: ", i, j);
            scanf("%f", &matrix[i][j]);
        }
    }

    gaussJordan(matrix, n);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{Enter number of variables: 3 \\
Enter augmented matrix coefficients (Ax = b): \\
matrix[0][0]: 2\\
matrix[0][1]: 1\\
matrix[0][2]: -1\\
matrix[0][3]: 8\\
matrix[1][0]: -3\\
matrix[1][1]: -1\\
matrix[1][2]: 2\\
matrix[1][3]: -11\\
matrix[2][0]: -2\\
matrix[2][1]: 1\\
matrix[2][2]: 2\\
matrix[2][3]: -3\\
\\
Solution:\\
x1 = 2.000\\
x2 = 3.000\\
x3 = -1.000}
\end{tcolorbox}

\newpage
\section*{Experiment 4: Gauss Elimination Method}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>

#define SIZE 10

void gaussElimination(float matrix[SIZE][SIZE], int n) {
    int i, j, k;
    float ratio;
    float x[SIZE];

    // Forward Elimination
    for (i = 0; i < n - 1; i++) {
        if (matrix[i][i] == 0.0) {
            printf("Mathematical Error: Division by zero\n");
            return;
        }
        for (j = i + 1; j < n; j++) {
            ratio = matrix[j][i] / matrix[i][i];
            for (k = 0; k <= n; k++) {
                matrix[j][k] -= ratio * matrix[i][k];
            }
        }
    }

    // Back Substitution
    x[n - 1] = matrix[n - 1][n] / matrix[n - 1][n - 1];
    for (i = n - 2; i >= 0; i--) {
        x[i] = matrix[i][n];
        for (j = i + 1; j < n; j++) {
            x[i] -= matrix[i][j] * x[j];
        }
        x[i] = x[i] / matrix[i][i];
    }

    // Print Solution
    printf("\nSolution:\n");
    for (i = 0; i < n; i++) {
        printf("x%d = %.3f\n", i + 1, x[i]);
    }
}

int main() {
    float matrix[SIZE][SIZE];
    int n, i, j;

    printf("Enter number of variables: ");
    scanf("%d", &n);

    printf("Enter augmented matrix (Ax = b):\n");
    for (i = 0; i < n; i++) {
        for (j = 0; j <= n; j++) {
            printf("matrix[%d][%d]: ", i, j);
            scanf("%f", &matrix[i][j]);
        }
    }

    gaussElimination(matrix, n);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{Enter number of variables: 3 \\
Enter augmented matrix (Ax = b): \\
matrix[0][0]: 2 \\
matrix[0][1]: 1 \\
matrix[0][2]: -1 \\
matrix[0][3]: 8 \\
matrix[1][0]: -3 \\
matrix[1][1]: -1 \\
matrix[1][2]: 2 \\
matrix[1][3]: -11 \\
matrix[2][0]: -2 \\
matrix[2][1]: 1 \\
matrix[2][2]: 2 \\
matrix[2][3]: -3 \\
\\
Solution: \\
x1 = 2.000 \\
x2 = 3.000 \\
x3 = -1.000}
\end{tcolorbox}

\newpage
\section*{Experiment 5: Singly Linked List Operations (Insert, Delete by Value, Reverse, Display)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* head = NULL;

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// Insert a node at the end
void insert(int value) {
    struct Node* newNode = createNode(value);
    if (head == NULL) {
        head = newNode;
        return;
    }

    struct Node* temp = head;
    while (temp->next != NULL)
        temp = temp->next;

    temp->next = newNode;
}

// Delete node by value
void deleteByValue(int value) {
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node *temp = head, *prev = NULL;

    while (temp != NULL && temp->data != value) {
        prev = temp;
        temp = temp->next;
    }

    if (temp == NULL) {
        printf("Value not found\n");
        return;
    }

    if (prev == NULL) {
        head = head->next;
    } else {
        prev->next = temp->next;
    }

    free(temp);
    printf("Deleted %d\n", value);
}

// Reverse the linked list
void reverse() {
    struct Node *prev = NULL, *curr = head, *next = NULL;

    while (curr != NULL) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }

    head = prev;
    printf("List reversed.\n");
}

// Display the linked list
void display() {
    struct Node* temp = head;

    printf("Linked List: ");
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Main function with menu
int main() {
    int choice, value;

    do {
        printf("\n1. Insert\n2. Delete by value\n3. Reverse\n4. Display\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                insert(value);
                break;
            case 2:
                printf("Enter value to delete: ");
                scanf("%d", &value);
                deleteByValue(value);
                break;
            case 3:
                reverse();
                break;
            case 4:
                display();
                break;
        }

    } while (choice != 5);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{1. Insert\\2. Delete by value\\3. Reverse\\4. Display\\5. Exit\\
Enter your choice: 1\\
Enter value to insert: 10\\
Enter your choice: 1\\
Enter value to insert: 20\\
Enter your choice: 1\\
Enter value to insert: 30\\
Enter your choice: 4\\
Linked List: 10 -> 20 -> 30 -> NULL\\
Enter your choice: 2\\
Enter value to delete: 20\\
Deleted 20\\
Enter your choice: 4\\
Linked List: 10 -> 30 -> NULL\\
Enter your choice: 3\\
List reversed.\\
Enter your choice: 4\\
Linked List: 30 -> 10 -> NULL}
\end{tcolorbox}

\newpage
\section*{Experiment 6: Doubly Linked List Operations (Insert, Delete by Value, Reverse, Display)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define node
struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};

struct Node* head = NULL;

// Create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->prev = NULL;
    newNode->next = NULL;
    return newNode;
}

// Insert at end
void insert(int value) {
    struct Node* newNode = createNode(value);
    if (head == NULL) {
        head = newNode;
        return;
    }
    struct Node* temp = head;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
    newNode->prev = temp;
}

// Delete by value
void deleteByValue(int value) {
    struct Node* temp = head;

    while (temp != NULL && temp->data != value) {
        temp = temp->next;
    }

    if (temp == NULL) {
        printf("Value not found\n");
        return;
    }

    if (temp->prev != NULL)
        temp->prev->next = temp->next;
    else
        head = temp->next;

    if (temp->next != NULL)
        temp->next->prev = temp->prev;

    free(temp);
    printf("Deleted %d\n", value);
}

// Reverse the list
void reverse() {
    struct Node *curr = head, *temp = NULL;

    while (curr != NULL) {
        // Swap next and prev
        temp = curr->prev;
        curr->prev = curr->next;
        curr->next = temp;
        curr = curr->prev;
    }

    // After loop, temp points to the previous of last node
    if (temp != NULL)
        head = temp->prev;
}

// Display list
void display() {
    struct Node* temp = head;
    printf("Doubly Linked List: ");
    while (temp != NULL) {
        printf("%d <-> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

int main() {
    int choice, value;

    do {
        printf("\n1. Insert\n2. Delete by value\n3. Reverse\n4. Display\n5. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                insert(value);
                break;
            case 2:
                printf("Enter value to delete: ");
                scanf("%d", &value);
                deleteByValue(value);
                break;
            case 3:
                reverse();
                printf("List reversed.\n");
                break;
            case 4:
                display();
                break;
        }

    } while (choice != 5);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{1. Insert\\2. Delete by value\\3. Reverse\\4. Display\\5. Exit\\
Enter choice: 1\\
Enter value to insert: 10\\
Enter choice: 1\\
Enter value to insert: 20\\
Enter choice: 1\\
Enter value to insert: 30\\
Enter choice: 4\\
Doubly Linked List: 10 <-> 20 <-> 30 <-> NULL\\
Enter choice: 2\\
Enter value to delete: 20\\
Deleted 20\\
Enter choice: 4\\
Doubly Linked List: 10 <-> 30 <-> NULL\\
Enter choice: 3\\
List reversed.\\
Enter choice: 4\\
Doubly Linked List: 30 <-> 10 <-> NULL}
\end{tcolorbox}

\newpage
\section*{Experiment 7: Circular Singly Linked List Operations (Insert, Delete by Value, Reverse, Display)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* head = NULL;

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// Insert a node at the end
void insert(int value) {
    struct Node* newNode = createNode(value);
    if (head == NULL) {
        head = newNode;
        newNode->next = head;
        return;
    }

    struct Node* temp = head;
    while (temp->next != head)
        temp = temp->next;

    temp->next = newNode;
    newNode->next = head;
}

// Delete a node by value
void deleteByValue(int value) {
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node *temp = head, *prev = NULL;

    if (head->data == value) {
        if (head->next == head) {
            free(head);
            head = NULL;
            printf("Deleted %d\n", value);
            return;
        }

        struct Node* last = head;
        while (last->next != head)
            last = last->next;

        last->next = head->next;
        temp = head;
        head = head->next;
        free(temp);
        printf("Deleted %d\n", value);
        return;
    }

    do {
        prev = temp;
        temp = temp->next;
    } while (temp != head && temp->data != value);

    if (temp == head) {
        printf("Value not found\n");
        return;
    }

    prev->next = temp->next;
    free(temp);
    printf("Deleted %d\n", value);
}

// Reverse the circular linked list
void reverse() {
    if (head == NULL || head->next == head) {
        printf("List reversed.\n");
        return;
    }

    struct Node *prev = NULL, *curr = head, *next = NULL, *last = head;

    while (last->next != head)
        last = last->next;

    do {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    } while (curr != head);

    head->next = prev;
    head = prev;
    last->next = head;

    printf("List reversed.\n");
}

// Display the circular linked list
void display() {
    if (head == NULL) {
        printf("Circular Linked List is empty\n");
        return;
    }

    struct Node* temp = head;
    printf("Circular Linked List: ");
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("(head)\n");
}

// Main function with menu
int main() {
    int choice, value;

    do {
        printf("\n1. Insert\n2. Delete by value\n3. Reverse\n4. Display\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                insert(value);
                break;
            case 2:
                printf("Enter value to delete: ");
                scanf("%d", &value);
                deleteByValue(value);
                break;
            case 3:
                reverse();
                break;
            case 4:
                display();
                break;
        }

    } while (choice != 5);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{1. Insert\\2. Delete by value\\3. Reverse\\4. Display\\5. Exit\\
Enter your choice: 1\\
Enter value to insert: 10\\
Enter your choice: 1\\
Enter value to insert: 20\\
Enter your choice: 1\\
Enter value to insert: 30\\
Enter your choice: 4\\
Circular Linked List: 10 -> 20 -> 30 -> (head)\\
Enter your choice: 2\\
Enter value to delete: 20\\
Deleted 20\\
Enter your choice: 4\\
Circular Linked List: 10 -> 30 -> (head)\\
Enter your choice: 3\\
List reversed.\\
Enter your choice: 4\\
Circular Linked List: 30 -> 10 -> (head)}
\end{tcolorbox}

\newpage
\section*{Experiment 8: Circular Doubly Linked List Operations (Insert, Delete by Value, Reverse, Display)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

struct Node* head = NULL;

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    newNode->prev = NULL;
    return newNode;
}

// Insert a node at the end
void insert(int value) {
    struct Node* newNode = createNode(value);
    if (head == NULL) {
        head = newNode;
        newNode->next = head;
        newNode->prev = head;
        return;
    }

    struct Node* tail = head->prev;
    tail->next = newNode;
    newNode->prev = tail;
    newNode->next = head;
    head->prev = newNode;
}

// Delete a node by value
void deleteByValue(int value) {
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node* temp = head;

    do {
        if (temp->data == value) {
            if (temp->next == temp && temp->prev == temp) {
                free(temp);
                head = NULL;
                printf("Deleted %d\n", value);
                return;
            }

            temp->prev->next = temp->next;
            temp->next->prev = temp->prev;

            if (temp == head) {
                head = temp->next;
            }

            free(temp);
            printf("Deleted %d\n", value);
            return;
        }
        temp = temp->next;
    } while (temp != head);

    printf("Value not found\n");
}

// Reverse the doubly circular linked list
void reverse() {
    if (head == NULL || head->next == head) {
        printf("List reversed.\n");
        return;
    }

    struct Node *curr = head, *temp = NULL;

    do {
        temp = curr->prev;
        curr->prev = curr->next;
        curr->next = temp;
        curr = curr->prev;
    } while (curr != head);

    head = temp->prev;
    printf("List reversed.\n");
}

// Display the doubly circular linked list
void display() {
    if (head == NULL) {
        printf("Doubly Circular Linked List is empty\n");
        return;
    }

    struct Node* temp = head;
    printf("Doubly Circular Linked List: ");
    do {
        printf("%d <-> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("(head)\n");
}

// Main function with menu
int main() {
    int choice, value;

    do {
        printf("\n1. Insert\n2. Delete by value\n3. Reverse\n4. Display\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                insert(value);
                break;
            case 2:
                printf("Enter value to delete: ");
                scanf("%d", &value);
                deleteByValue(value);
                break;
            case 3:
                reverse();
                break;
            case 4:
                display();
                break;
        }

    } while (choice != 5);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{1. Insert\\2. Delete by value\\3. Reverse\\4. Display\\5. Exit\\
Enter your choice: 1\\
Enter value to insert: 11\\
Enter your choice: 1\\
Enter value to insert: 22\\
Enter your choice: 1\\
Enter value to insert: 33\\
Enter your choice: 4\\
Doubly Circular Linked List: 11 <-> 22 <-> 33 <-> (head)\\
Enter your choice: 2\\
Enter value to delete: 22\\
Deleted 22\\
Enter your choice: 4\\
Doubly Circular Linked List: 11 <-> 33 <-> (head)\\
Enter your choice: 3\\
List reversed.\\
Enter your choice: 4\\
Doubly Circular Linked List: 33 <-> 11 <-> (head)}
\end{tcolorbox}

\newpage
\section*{Experiment 9: Stack Implementation using Array}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#define MAX 100

int stack[MAX];
int top = -1;

// Function to push an element onto the stack
void push(int value) {
    if (top == MAX - 1) {
        printf("Stack Overflow! Cannot push %d\n", value);
        return;
    }
    stack[++top] = value;
    printf("Pushed %d onto the stack\n", value);
}

// Function to pop an element from the stack
void pop() {
    if (top == -1) {
        printf("Stack Underflow! Cannot pop\n");
        return;
    }
    printf("Popped %d from the stack\n", stack[top--]);
}

// Function to peek at the top element of the stack
void peek() {
    if (top == -1) {
        printf("Stack is empty\n");
        return;
    }
    printf("Top element is %d\n", stack[top]);
}

// Function to display the stack
void display() {
    if (top == -1) {
        printf("Stack is empty\n");
        return;
    }
    printf("Stack elements: ");
    for (int i = top; i >= 0; i--) {
        printf("%d ", stack[i]);
    }
    printf("\n");
}

// Main function with menu
int main() {
    int choice, value;

    do {
        printf("\n1. Push\n2. Pop\n3. Peek\n4. Display\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to push: ");
                scanf("%d", &value);
                push(value);
                break;
            case 2:
                pop();
                break;
            case 3:
                peek();
                break;
            case 4:
                display();
                break;
            case 5:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice, please try again\n");
        }
    } while (choice != 5);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{1. Push\\2. Pop\\3. Peek\\4. Display\\5. Exit\\
Enter your choice: 1\\
Enter value to push: 5\\
Pushed 5 onto the stack\\
Enter your choice: 1\\
Enter value to push: 10\\
Pushed 10 onto the stack\\
Enter your choice: 4\\
Stack elements: 10 5 \\
Enter your choice: 3\\
Top element is 10\\
Enter your choice: 2\\
Popped 10 from the stack\\
Enter your choice: 4\\
Stack elements: 5}
\end{tcolorbox}

\newpage
\section*{Experiment 10: Stack Implementation using Linked List}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* top = NULL;

// Function to push an element onto the stack
void push(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Stack Overflow! Cannot push %d\n", value);
        return;
    }
    newNode->data = value;
    newNode->next = top;
    top = newNode;
    printf("Pushed %d onto the stack\n", value);
}

// Function to pop an element from the stack
void pop() {
    if (top == NULL) {
        printf("Stack Underflow! Cannot pop\n");
        return;
    }
    struct Node* temp = top;
    printf("Popped %d from the stack\n", top->data);
    top = top->next;
    free(temp);
}

// Function to peek at the top element of the stack
void peek() {
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    }
    printf("Top element is %d\n", top->data);
}

// Function to display the stack
void display() {
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    }
    struct Node* temp = top;
    printf("Stack elements: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

// Main function with menu
int main() {
    int choice, value;

    do {
        printf("\n1. Push\n2. Pop\n3. Peek\n4. Display\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to push: ");
                scanf("%d", &value);
                push(value);
                break;
            case 2:
                pop();
                break;
            case 3:
                peek();
                break;
            case 4:
                display();
                break;
            case 5:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice, please try again\n");
        }
    } while (choice != 5);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{1. Push\\2. Pop\\3. Peek\\4. Display\\5. Exit\\
Enter your choice: 1\\
Enter value to push: 100\\
Pushed 100 onto the stack\\
Enter your choice: 1\\
Enter value to push: 200\\
Pushed 200 onto the stack\\
Enter your choice: 4\\
Stack elements: 200 100 \\
Enter your choice: 3\\
Top element is 200\\
Enter your choice: 2\\
Popped 200 from the stack\\
Enter your choice: 4\\
Stack elements: 100}
\end{tcolorbox}

\newpage
\section*{Experiment 11: Queue using Array}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#define MAX 100

int queue[MAX];
int front = -1, rear = -1;

void enqueue(int value) {
    if (rear == MAX - 1) {
        printf("Queue Overflow! Cannot enqueue %d\n", value);
        return;
    }
    if (front == -1) {
        front = 0;
    }
    queue[++rear] = value;
    printf("Enqueued %d into the queue\n", value);
}

void dequeue() {
    if (front == -1 || front > rear) {
        printf("Queue Underflow! Cannot dequeue\n");
        return;
    }
    printf("Dequeued %d from the queue\n", queue[front++]);
    if (front > rear) {
        front = rear = -1;
    }
}

void display() {
    if (front == -1 || front > rear) {
        printf("Queue is empty\n");
        return;
    }
    printf("Queue elements: ");
    for (int i = front; i <= rear; i++) {
        printf("%d ", queue[i]);
    }
    printf("\n");
}

int main() {
    int choice, value;

    do {
        printf("\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to enqueue: ");
                scanf("%d", &value);
                enqueue(value);
                break;
            case 2:
                dequeue();
                break;
            case 3:
                display();
                break;
            case 4:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice, please try again\n");
        }
    } while (choice != 4);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{1. Enqueue\\2. Dequeue\\3. Display\\4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 10\\
Enqueued 10 into the queue\\
Enter your choice: 1\\
Enter value to enqueue: 20\\
Enqueued 20 into the queue\\
Enter your choice: 3\\
Queue elements: 10 20\\
Enter your choice: 2\\
Dequeued 10 from the queue\\
Enter your choice: 3\\
Queue elements: 20}
\end{tcolorbox}

\newpage
\section*{Experiment 12: Queue using Linked List}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* front = NULL;
struct Node* rear = NULL;

void enqueue(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Memory allocation failed! Cannot enqueue %d\n", value);
        return;
    }
    newNode->data = value;
    newNode->next = NULL;

    if (rear == NULL) {
        front = rear = newNode;
        printf("Enqueued %d into the queue\n", value);
        return;
    }

    rear->next = newNode;
    rear = newNode;
    printf("Enqueued %d into the queue\n", value);
}

void dequeue() {
    if (front == NULL) {
        printf("Queue Underflow! Cannot dequeue\n");
        return;
    }

    struct Node* temp = front;
    printf("Dequeued %d from the queue\n", front->data);
    front = front->next;

    if (front == NULL) {
        rear = NULL;
    }

    free(temp);
}

void display() {
    if (front == NULL) {
        printf("Queue is empty\n");
        return;
    }

    struct Node* temp = front;
    printf("Queue elements: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    int choice, value;

    do {
        printf("\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to enqueue: ");
                scanf("%d", &value);
                enqueue(value);
                break;
            case 2:
                dequeue();
                break;
            case 3:
                display();
                break;
            case 4:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice, please try again\n");
        }
    } while (choice != 4);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{1. Enqueue\\2. Dequeue\\3. Display\\4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 100\\
Enqueued 100 into the queue\\
Enter your choice: 1\\
Enter value to enqueue: 200\\
Enqueued 200 into the queue\\
Enter your choice: 3\\
Queue elements: 100 200\\
Enter your choice: 2\\
Dequeued 100 from the queue\\
Enter your choice: 3\\
Queue elements: 200}
\end{tcolorbox}

\newpage
\section*{Experiment 13: Circular Queue using Array}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#define MAX 5

int queue[MAX];
int front = -1, rear = -1;

void enqueue(int value) {
    if ((rear + 1) % MAX == front) {
        printf("Queue Overflow! Cannot enqueue %d\n", value);
        return;
    }
    if (front == -1) {
        front = 0;
    }
    rear = (rear + 1) % MAX;
    queue[rear] = value;
    printf("Enqueued %d into the queue\n", value);
}

void dequeue() {
    if (front == -1) {
        printf("Queue Underflow! Cannot dequeue\n");
        return;
    }
    printf("Dequeued %d from the queue\n", queue[front]);
    if (front == rear) {
        front = rear = -1;
    } else {
        front = (front + 1) % MAX;
    }
}

void display() {
    if (front == -1) {
        printf("Queue is empty\n");
        return;
    }
    printf("Queue elements: ");
    int i = front;
    while (1) {
        printf("%d ", queue[i]);
        if (i == rear) break;
        i = (i + 1) % MAX;
    }
    printf("\n");
}

int main() {
    int choice, value;

    do {
        printf("\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to enqueue: ");
                scanf("%d", &value);
                enqueue(value);
                break;
            case 2:
                dequeue();
                break;
            case 3:
                display();
                break;
            case 4:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice, please try again\n");
        }
    } while (choice != 4);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{1. Enqueue\\2. Dequeue\\3. Display\\4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 1\\
Enqueued 1 into the queue\\
Enter your choice: 1\\
Enter value to enqueue: 2\\
Enqueued 2 into the queue\\
Enter your choice: 1\\
Enter value to enqueue: 3\\
Enqueued 3 into the queue\\
Enter your choice: 3\\
Queue elements: 1 2 3\\
Enter your choice: 2\\
Dequeued 1 from the queue\\
Enter your choice: 3\\
Queue elements: 2 3}
\end{tcolorbox}

\newpage
\section*{Experiment 14: Circular Queue using Linked List}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* front = NULL;
struct Node* rear = NULL;

void enqueue(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Memory allocation failed! Cannot enqueue %d\n", value);
        return;
    }
    newNode->data = value;
    newNode->next = NULL;

    if (front == NULL) {
        front = rear = newNode;
        rear->next = front;
        printf("Enqueued %d into the queue\n", value);
        return;
    }

    rear->next = newNode;
    rear = newNode;
    rear->next = front;
    printf("Enqueued %d into the queue\n", value);
}

void dequeue() {
    if (front == NULL) {
        printf("Queue Underflow! Cannot dequeue\n");
        return;
    }

    struct Node* temp = front;
    if (front == rear) {
        front = rear = NULL;
    } else {
        front = front->next;
        rear->next = front;
    }

    printf("Dequeued %d from the queue\n", temp->data);
    free(temp);
}

void display() {
    if (front == NULL) {
        printf("Queue is empty\n");
        return;
    }

    struct Node* temp = front;
    printf("Queue elements: ");
    do {
        printf("%d ", temp->data);
        temp = temp->next;
    } while (temp != front);
    printf("\n");
}

int main() {
    int choice, value;

    do {
        printf("\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to enqueue: ");
                scanf("%d", &value);
                enqueue(value);
                break;
            case 2:
                dequeue();
                break;
            case 3:
                display();
                break;
            case 4:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice, please try again\n");
        }
    } while (choice != 4);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{1. Enqueue\\2. Dequeue\\3. Display\\4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 11\\
Enqueued 11 into the queue\\
Enter your choice: 1\\
Enter value to enqueue: 22\\
Enqueued 22 into the queue\\
Enter your choice: 3\\
Queue elements: 11 22\\
Enter your choice: 2\\
Dequeued 11 from the queue\\
Enter your choice: 3\\
Queue elements: 22}
\end{tcolorbox}

\newpage
\section*{Experiment 15: Binary Tree Operations (Creation, Traversals, Height)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a tree node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to build the binary tree dynamically
struct Node* buildTree() {
    int value;
    printf("Enter data (-1 for no node): ");
    scanf("%d", &value);

    if (value == -1) {
        return NULL;
    }

    struct Node* newNode = createNode(value);
    printf("Enter left child of %d:\n", value);
    newNode->left = buildTree();
    printf("Enter right child of %d:\n", value);
    newNode->right = buildTree();

    return newNode;
}

// Inorder Traversal (Left, Root, Right)
void inorderTraversal(struct Node* root) {
    if (root == NULL) return;
    inorderTraversal(root->left);
    printf("%d ", root->data);
    inorderTraversal(root->right);
}

// Preorder Traversal (Root, Left, Right)
void preorderTraversal(struct Node* root) {
    if (root == NULL) return;
    printf("%d ", root->data);
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}

// Postorder Traversal (Left, Right, Root)
void postorderTraversal(struct Node* root) {
    if (root == NULL) return;
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    printf("%d ", root->data);
}

// Function to find the height of the binary tree
int findHeight(struct Node* root) {
    if (root == NULL) return -1;
    int leftHeight = findHeight(root->left);
    int rightHeight = findHeight(root->right);
    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;
}

int main() {
    printf("Build the binary tree:\n");
    struct Node* root = buildTree();

    printf("\nInorder Traversal: ");
    inorderTraversal(root);
    printf("\n");

    printf("Preorder Traversal: ");
    preorderTraversal(root);
    printf("\n");

    printf("Postorder Traversal: ");
    postorderTraversal(root);
    printf("\n");

    printf("Height of the binary tree: %d\n", findHeight(root));

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{Build the binary tree: \\
Enter data (-1 for no node): 10 \\
Enter left child of 10:\\
Enter data (-1 for no node): 5 \\
Enter left child of 5:\\
Enter data (-1 for no node): -1 \\
Enter right child of 5:\\
Enter data (-1 for no node): -1 \\
Enter right child of 10:\\
Enter data (-1 for no node): 20 \\
Enter left child of 20:\\
Enter data (-1 for no node): -1 \\
Enter right child of 20:\\
Enter data (-1 for no node): -1 \\
\\
Inorder Traversal: 5 10 20\\
Preorder Traversal: 10 5 20\\
Postorder Traversal: 5 20 10\\
Height of the binary tree: 1}
\end{tcolorbox}

\newpage
\section*{Experiment 16: Implementation of Binary Search Tree (BST) and Operations}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node in BST
struct Node* insert(struct Node* root, int value) {
    if (root == NULL)
        return createNode(value);

    if (value < root->data)
        root->left = insert(root->left, value);
    else if (value > root->data)
        root->right = insert(root->right, value);

    return root;
}

// Inorder traversal (LNR)
void inorder(struct Node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

// Preorder traversal (NLR)
void preorder(struct Node* root) {
    if (root != NULL) {
        printf("%d ", root->data);
        preorder(root->left);
        preorder(root->right);
    }
}

// Postorder traversal (LRN)
void postorder(struct Node* root) {
    if (root != NULL) {
        postorder(root->left);
        postorder(root->right);
        printf("%d ", root->data);
    }
}

// Function to calculate height of BST
int height(struct Node* root) {
    if (root == NULL)
        return -1;

    int leftHeight = height(root->left);
    int rightHeight = height(root->right);

    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;
}

int main() {
    struct Node* root = NULL;
    int choice, value;

    do {
        printf("\n1. Insert\n2. Inorder\n3. Preorder\n4. Postorder\n5. Height\n6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                root = insert(root, value);
                break;
            case 2:
                printf("Inorder Traversal: ");
                inorder(root);
                printf("\n");
                break;
            case 3:
                printf("Preorder Traversal: ");
                preorder(root);
                printf("\n");
                break;
            case 4:
                printf("Postorder Traversal: ");
                postorder(root);
                printf("\n");
                break;
            case 5:
                printf("Height of tree: %d\n", height(root));
                break;
            case 6:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice\n");
        }

    } while (choice != 6);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{1. Insert\\2. Inorder\\3. Preorder\\4. Postorder\\5. Height\\6. Exit\\
Enter your choice: 1\\
Enter value to insert: 40\\
Enter your choice: 1\\
Enter value to insert: 20\\
Enter your choice: 1\\
Enter value to insert: 60\\
Enter your choice: 1\\
Enter value to insert: 10\\
Enter your choice: 2\\
Inorder Traversal: 10 20 40 60\\
Enter your choice: 3\\
Preorder Traversal: 40 20 10 60\\
Enter your choice: 4\\
Postorder Traversal: 10 20 60 40\\
Enter your choice: 5\\
Height of tree: 2}
\end{tcolorbox}

\newpage
\section*{Experiment 17: AVL Tree Operations (Insert, Delete, Search, Traversal, Height)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
    int height;
};

int getHeight(struct Node* node) {
    return (node == NULL) ? -1 : node->height;
}

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = newNode->right = NULL;
    newNode->height = 0;
    return newNode;
}

int getBalanceFactor(struct Node* node) {
    return (node == NULL) ? 0 : getHeight(node->left) - getHeight(node->right);
}

struct Node* rightRotate(struct Node* y) {
    struct Node* x = y->left;
    struct Node* T2 = x->right;

    x->right = y;
    y->left = T2;

    y->height = 1 + (getHeight(y->left) > getHeight(y->right)
                    ? getHeight(y->left) : getHeight(y->right));
    x->height = 1 + (getHeight(x->left) > getHeight(x->right)
                    ? getHeight(x->left) : getHeight(x->right));
    return x;
}

struct Node* leftRotate(struct Node* x) {
    struct Node* y = x->right;
    struct Node* T2 = y->left;

    y->left = x;
    x->right = T2;

    x->height = 1 + (getHeight(x->left) > getHeight(x->right)
                    ? getHeight(x->left) : getHeight(x->right));
    y->height = 1 + (getHeight(y->left) > getHeight(y->right)
                    ? getHeight(y->left) : getHeight(y->right));
    return y;
}

struct Node* insert(struct Node* node, int value) {
    if (node == NULL) return createNode(value);

    if (value < node->data) node->left = insert(node->left, value);
    else if (value > node->data) node->right = insert(node->right, value);
    else return node;

    node->height = 1 + (getHeight(node->left) > getHeight(node->right)
                        ? getHeight(node->left) : getHeight(node->right));

    int balance = getBalanceFactor(node);

    if (balance > 1 && value < node->left->data) return rightRotate(node);
    if (balance < -1 && value > node->right->data) return leftRotate(node);
    if (balance > 1 && value > node->left->data) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }
    if (balance < -1 && value < node->right->data) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }

    return node;
}

struct Node* findMin(struct Node* node) {
    while (node->left != NULL) node = node->left;
    return node;
}

struct Node* deleteNode(struct Node* root, int value) {
    if (root == NULL) return root;

    if (value < root->data) root->left = deleteNode(root->left, value);
    else if (value > root->data) root->right = deleteNode(root->right, value);
    else {
        if (!root->left || !root->right) {
            struct Node* temp = root->left ? root->left : root->right;
            if (temp == NULL) {
                temp = root;
                root = NULL;
            } else *root = *temp;
            free(temp);
        } else {
            struct Node* temp = findMin(root->right);
            root->data = temp->data;
            root->right = deleteNode(root->right, temp->data);
        }
    }

    if (root == NULL) return root;

    root->height = 1 + (getHeight(root->left) > getHeight(root->right)
                        ? getHeight(root->left) : getHeight(root->right));

    int balance = getBalanceFactor(root);

    if (balance > 1 && getBalanceFactor(root->left) >= 0) return rightRotate(root);
    if (balance > 1 && getBalanceFactor(root->left) < 0) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }
    if (balance < -1 && getBalanceFactor(root->right) <= 0) return leftRotate(root);
    if (balance < -1 && getBalanceFactor(root->right) > 0) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }

    return root;
}

int search(struct Node* root, int value) {
    if (root == NULL) return 0;
    if (value == root->data) return 1;
    return (value < root->data) ? search(root->left, value) : search(root->right, value);
}

void inorderTraversal(struct Node* root) {
    if (root == NULL) return;
    inorderTraversal(root->left);
    printf("%d ", root->data);
    inorderTraversal(root->right);
}

int main() {
    struct Node* root = NULL;
    int choice, value;

    do {
        printf("\n1. Insert\n2. Delete\n3. Search\n4. Inorder Traversal\n5. Height of Tree\n6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                root = insert(root, value);
                break;
            case 2:
                printf("Enter value to delete: ");
                scanf("%d", &value);
                root = deleteNode(root, value);
                break;
            case 3:
                printf("Enter value to search: ");
                scanf("%d", &value);
                if (search(root, value))
                    printf("Value found in the tree\n");
                else
                    printf("Value not found in the tree\n");
                break;
            case 4:
                printf("Inorder Traversal: ");
                inorderTraversal(root);
                printf("\n");
                break;
            case 5:
                printf("Height of the tree: %d\n", getHeight(root));
                break;
            case 6:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice, please try again\n");
        }
    } while (choice != 6);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{1. Insert\\2. Delete\\3. Search\\4. Inorder Traversal\\5. Height of Tree\\6. Exit\\
Enter your choice: 1\\
Enter value to insert: 50\\
Enter your choice: 1\\
Enter value to insert: 30\\
Enter your choice: 1\\
Enter value to insert: 70\\
Enter your choice: 1\\
Enter value to insert: 20\\
Enter your choice: 4\\
Inorder Traversal: 20 30 50 70\\
Enter your choice: 3\\
Enter value to search: 30\\
Value found in the tree\\
Enter your choice: 2\\
Enter value to delete: 30\\
Enter your choice: 4\\
Inorder Traversal: 20 50 70\\
Enter your choice: 5\\
Height of the tree: 1}
\end{tcolorbox}

\newpage
\section*{Experiment 18: Implementation of Various Sorting Algorithms (Bubble, Insertion, Selection, Quick Sort)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++)
        for (int j = 0; j < n - i - 1; j++)
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
}

void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i], j = i - 1;
        while (j >= 0 && arr[j] > key)
            arr[j + 1] = arr[j--];
        arr[j + 1] = key;
    }
}

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;
        for (int j = i + 1; j < n; j++)
            if (arr[j] < arr[minIdx])
                minIdx = j;
        int temp = arr[minIdx];
        arr[minIdx] = arr[i];
        arr[i] = temp;
    }
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high], i = low - 1;
    for (int j = low; j <= high - 1; j++)
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return i + 1;
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

void display(int arr[], int n) {
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int arr[100], n, choice;

    printf("Enter number of elements: ");
    scanf("%d", &n);
    printf("Enter %d elements: ", n);
    for (int i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    do {
        printf("\n1. Bubble Sort\n2. Insertion Sort\n3. Selection Sort\n4. Quick Sort\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        int temp[100];
        for (int i = 0; i < n; i++)
            temp[i] = arr[i];

        switch (choice) {
            case 1:
                bubbleSort(temp, n);
                printf("Sorted using Bubble Sort: ");
                display(temp, n);
                break;
            case 2:
                insertionSort(temp, n);
                printf("Sorted using Insertion Sort: ");
                display(temp, n);
                break;
            case 3:
                selectionSort(temp, n);
                printf("Sorted using Selection Sort: ");
                display(temp, n);
                break;
            case 4:
                quickSort(temp, 0, n - 1);
                printf("Sorted using Quick Sort: ");
                display(temp, n);
                break;
            case 5:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice\n");
        }
    } while (choice != 5);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{Enter number of elements: 5\\
Enter 5 elements: 64 25 12 22 11\\
\\
1. Bubble Sort\\2. Insertion Sort\\3. Selection Sort\\4. Quick Sort\\5. Exit\\
Enter your choice: 1\\
Sorted using Bubble Sort: 11 12 22 25 64\\
Enter your choice: 2\\
Sorted using Insertion Sort: 11 12 22 25 64\\
Enter your choice: 3\\
Sorted using Selection Sort: 11 12 22 25 64\\
Enter your choice: 4\\
Sorted using Quick Sort: 11 12 22 25 64\\
Enter your choice: 5\\
Exiting...}
\end{tcolorbox}

\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage














\end{document}