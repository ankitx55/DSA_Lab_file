\documentclass[12pt,a4paper]{article}

\usepackage{listings}
\usepackage[most]{tcolorbox}
\usepackage{xcolor}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{float}

\titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}

% Define colors
\definecolor{silver}{RGB}{192, 192, 192} % New color for output background

\lstset{
  language=C,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{green!60!black},
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  numbersep=5pt,
  backgroundcolor=\color{white},
  frame=single,
  breaklines=true,
  tabsize=2,
  showstringspaces=false
}

% --- Box for Program Code Output ---
\tcbset{terminalstyle/.style={
    colback=silver!40!white, % changed from cream to silver!
    coltext=black,
    fonttitle=\bfseries,
    boxrule=0.5pt,
    arc=4pt,
    outer arc=4pt,
    boxsep=4pt,
    left=6pt,
    right=6pt,
    top=4pt,
    bottom=4pt,
    breakable
}}

% --- Box for Terminal Output (your output style) ---
\tcbset{creambox/.style={
    colback=silver!40!white, % changed from cream to silver here too
    colframe=black,
    fontupper=\ttfamily,
    boxrule=0.5pt,
    arc=2mm,
    outer arc=2mm,
    boxsep=4pt,
    left=6pt,
    right=6pt,
    top=6pt,
    bottom=6pt,
    breakable
}}

\begin{document}

\title{\textbf{Lab Manual}\\Data Structures in C}
\author{Ankit Kumar}
\date{\today}
\maketitle
\newpage
\section*{Experiment 1: Array Operations (Insert, Delete, Search, Sort, Display)}

\subsection*{Code}

\begin{lstlisting}
#include <stdio.h> // Standard input-output library

// Predefining the maximum array size
#define MAX 100

// Function to insert an element at a specific position
void insert(int arr[], int n, int pos, int val) {
    if (n >= MAX || pos < 0 || pos > n) { // Check if insertion is possible
        printf("Insertion not possible.\n");
        return;
    }
    // Shift elements to the right
    for (int i = n; i > pos; i--) {
        arr[i] = arr[i - 1];
    }
    arr[pos] = val; // Insert the new value
    n++; // Increase size (though here not updated outside function)

    // Display array after insertion
    printf("After insertion: ");
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

// Function to delete an element at a specific position
void delete(int arr[], int n, int pos) {
    if (n <= 0 || pos < 0 || pos >= n) { // Check if deletion is valid
        printf("Deletion not possible.\n");
        return;
    }
    // Shift elements to the left
    for (int i = pos; i < n - 1; i++) {
        arr[i] = arr[i + 1];
    }
    n--; // Decrease size (though here not updated outside function)

    // Display array after deletion
    printf("After deletion: ");
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

// Function to search for an element
void search(int arr[], int n, int key) {
    int found = 0; // Flag to track search
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) { // If element found
            printf("Element found at index %d\n", i);
            found = 1;
            break;
        }
    }
    if (!found) // If element not found
        printf("Element not found.\n");
}

// Function to sort the array using Bubble Sort
void sort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) { // Loop through array elements
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) { // Swap if out of order
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    // Display array after sorting
    printf("Sorted array: ");
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

// Function to display array elements
void display(int arr[], int n) {
    printf("Array: ");
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

// Main function
int main() {
    int arr[MAX], n, choice, val, pos, key; // Variable declarations

    // Input array size
    printf("Enter number of elements: ");
    scanf("%d", &n);

    // Input array elements
    printf("Enter %d elements:\n", n);
    for (int i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    // Menu-driven program
    do {
        printf("\n--- MENU ---\n");
        printf("1. Insert\n2. Delete\n3. Search\n4. Sort\n5. Display\n6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        // Switch case to perform user selected operation
        switch (choice) {
            case 1:
                printf("Enter position (0 to %d): ", n);
                scanf("%d", &pos);
                printf("Enter value to insert: ");
                scanf("%d", &val);
                insert(arr, n, pos, val);
                break;

            case 2:
                printf("Enter position to delete (0 to %d): ", n - 1);
                scanf("%d", &pos);
                delete(arr, n, pos);
                break;

            case 3:
                printf("Enter value to search: ");
                scanf("%d", &key);
                search(arr, n, key);
                break;

            case 4:
                sort(arr, n);
                break;

            case 5:
                display(arr, n);
                break;

            case 6:
                printf("Exiting...\n");
                break;

            default:
                printf("Invalid choice.\n"); // If user enters wrong option
        }
    } while (choice != 6); // Repeat menu until user chooses Exit

    return 0;
}
\end{lstlisting}

\newpage

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 13:57:01 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 1.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
Enter the size of the array: 5\\
Enter elements:\\
10\\
20\\
30\\
40\\
50\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Sort\\
5. Display\\
6. Exit\\
Enter your choice: 5\\
Array elements:\\
10\t20\t30\t40\t50\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Sort\\
5. Display\\
6. Exit\\
Enter your choice: 1\\
Enter element to insert: 60\\
Enter position to insert (0 to 5): 2\\
Element inserted successfully.\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Sort\\
5. Display\\
6. Exit\\
Enter your choice: 5\\
Array elements:\\
10\t20\t60\t30\t40\t50\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Sort\\
5. Display\\
6. Exit\\
Enter your choice: 2\\
Enter position to delete (0 to 5): 3\\
Element deleted successfully.\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Sort\\
5. Display\\
6. Exit\\
Enter your choice: 5\\
Array elements:\\
10\t20\t60\t40\t50\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Sort\\
5. Display\\
6. Exit\\
Enter your choice: 3\\
Enter element to search: 40\\
Element found at position 3\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Sort\\
5. Display\\
6. Exit\\
Enter your choice: 4\\
Array sorted successfully.\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Sort\\
5. Display\\
6. Exit\\
Enter your choice: 5\\
Array elements:\\
10\t20\t40\t50\t60\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Sort\\
5. Display\\
6. Exit\\
Enter your choice: 6\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}












\newpage
\section*{Experiment 2: Matrix Row and Column Operations}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h> // Standard input-output header file

#define MAX_ROWS 10 // Maximum number of rows
#define MAX_COLS 10 // Maximum number of columns

// Function to display the matrix
void display(int arr[MAX_ROWS][MAX_COLS], int rows, int cols) {
    printf("Matrix:\n");
    for (int i = 0; i < rows; i++) { // Traverse each row
        for (int j = 0; j < cols; j++) { // Traverse each column
            printf("%d\t", arr[i][j]); // Print element with a tab space
        }
        printf("\n"); // Newline after each row
    }
}

// Function to insert a new row at a given position
void insertRow(int arr[MAX_ROWS][MAX_COLS], int *rows, int cols, int pos) {
    if (*rows >= MAX_ROWS || pos < 0 || pos > *rows) { // Boundary checks
        printf("Insertion not possible.\n");
        return;
    }

    // Shift rows downward to make space
    for (int i = *rows; i > pos; i--) {
        for (int j = 0; j < cols; j++) {
            arr[i][j] = arr[i - 1][j];
        }
    }

    // Input new row elements
    printf("Enter elements of new row:\n");
    for (int j = 0; j < cols; j++) {
        scanf("%d", &arr[pos][j]);
    }

    (*rows)++; // Increase row count
    printf("Row inserted.\n");
}

// Function to delete a row at a given position
void deleteRow(int arr[MAX_ROWS][MAX_COLS], int *rows, int cols, int pos) {
    if (*rows <= 0 || pos < 0 || pos >= *rows) { // Boundary checks
        printf("Deletion not possible.\n");
        return;
    }

    // Shift rows upward to overwrite the deleted row
    for (int i = pos; i < *rows - 1; i++) {
        for (int j = 0; j < cols; j++) {
            arr[i][j] = arr[i + 1][j];
        }
    }

    (*rows)--; // Decrease row count
    printf("Row deleted.\n");
}

// Function to insert a new column at a given position
void insertColumn(int arr[MAX_ROWS][MAX_COLS], int rows, int *cols, int pos) {
    if (*cols >= MAX_COLS || pos < 0 || pos > *cols) { // Boundary checks
        printf("Insertion not possible.\n");
        return;
    }

    // Shift columns to the right
    for (int i = 0; i < rows; i++) {
        for (int j = *cols; j > pos; j--) {
            arr[i][j] = arr[i][j - 1];
        }
    }

    // Input new column elements
    printf("Enter elements of new column:\n");
    for (int i = 0; i < rows; i++) {
        scanf("%d", &arr[i][pos]);
    }

    (*cols)++; // Increase column count
    printf("Column inserted.\n");
}

// Function to delete a column at a given position
void deleteColumn(int arr[MAX_ROWS][MAX_COLS], int rows, int *cols, int pos) {
    if (*cols <= 0 || pos < 0 || pos >= *cols) { // Boundary checks
        printf("Deletion not possible.\n");
        return;
    }

    // Shift columns to the left to overwrite the deleted column
    for (int i = 0; i < rows; i++) {
        for (int j = pos; j < *cols - 1; j++) {
            arr[i][j] = arr[i][j + 1];
        }
    }

    (*cols)--; // Decrease column count
    printf("Column deleted.\n");
}

// Main function
int main() {
    int arr[MAX_ROWS][MAX_COLS]; // Matrix declaration
    int rows, cols, choice, pos; // Variables for rows, columns, choices, positions

    // Input number of rows and columns
    printf("Enter number of rows and columns: ");
    scanf("%d %d", &rows, &cols);

    // Input matrix elements
    printf("Enter elements of matrix:\n");
    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            scanf("%d", &arr[i][j]);

    // Menu-driven operations
    do {
        printf("\n--- MENU ---\n");
        printf("1. Insert Row\n2. Delete Row\n3. Insert Column\n4. Delete Column\n5. Display\n6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        // Perform operation based on user choice
        switch (choice) {
            case 1:
                printf("Enter row position to insert (0 to %d): ", rows);
                scanf("%d", &pos);
                insertRow(arr, &rows, cols, pos);
                break;

            case 2:
                printf("Enter row position to delete (0 to %d): ", rows - 1);
                scanf("%d", &pos);
                deleteRow(arr, &rows, cols, pos);
                break;

            case 3:
                printf("Enter column position to insert (0 to %d): ", cols);
                scanf("%d", &pos);
                insertColumn(arr, rows, &cols, pos);
                break;

            case 4:
                printf("Enter column position to delete (0 to %d): ", cols - 1);
                scanf("%d", &pos);
                deleteColumn(arr, rows, &cols, pos);
                break;

            case 5:
                display(arr, rows, cols);
                break;

            case 6:
                printf("Exiting...\n");
                break;

            default:
                printf("Invalid choice.\n"); // Handle invalid menu option
        }

    } while (choice != 6); // Repeat until user selects Exit

    return 0;
}
\end{lstlisting}

\newpage
\subsection*{Output}
\begin{tcolorbox}[creambox]
Last login: Sat Apr 26 14:17:31 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 2.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
Enter number of rows and columns: 3\\
3\\
11\\
22\\
33\\
44\\
55\\
66\\
77\\
88\\
99\\
Enter elements of matrix:\\
--- MENU ---\\
1. Insert Row\\
2. Delete Row\\
3. Insert Column\\
4. Delete Column\\
5. Display\\
6. Exit\\
Enter your choice: 5\\
Matrix:\\
11 22 33\\
44 55 66\\
77 88 99\\
--- MENU ---\\
1. Insert Row\\
2. Delete Row\\
3. Insert Column\\
4. Delete Column\\
5. Display\\
6. Exit\\
Enter your choice: 2\\
Enter row position to delete (0 to 2): 1\\
Row deleted.\\
--- MENU ---\\
1. Insert Row\\
2. Delete Row\\
3. Insert Column\\
4. Delete Column\\
5. Display\\
6. Exit\\
Enter your choice: 5\\
Matrix:\\
11 22 33\\
77 88 99\\
--- MENU ---\\
1. Insert Row\\
2. Delete Row\\
3. Insert Column\\
4. Delete Column\\
5. Display\\
6. Exit\\
Enter your choice: 1\\
Enter row position to insert (0 to 2): 2\\
Enter elements of new row:\\
11\\
22\\
33\\
Row inserted.\\
--- MENU ---\\
1. Insert Row\\
2. Delete Row\\
3. Insert Column\\
4. Delete Column\\
5. Display\\
6. Exit\\
Enter your choice: 5\\
Matrix:\\
11 22 33\\
77 88 99\\
11 22 33\\
--- MENU ---\\
1. Insert Row\\
2. Delete Row\\
3. Insert Column\\
4. Delete Column\\
5. Display\\
6. Exit\\
Enter your choice: 4\\
Enter column position to delete (0 to 2): 1\\
Column deleted.\\
--- MENU ---\\
1. Insert Row\\
2. Delete Row\\
3. Insert Column\\
4. Delete Column\\
5. Display\\
6. Exit\\
Enter your choice: 5\\
Matrix:\\
11 33\\
77 99\\
11 33\\
--- MENU ---\\
1. Insert Row\\
2. Delete Row\\
3. Insert Column\\
4. Delete Column\\
5. Display\\
6. Exit\\
Enter your choice: 3\\
Enter column position to insert (0 to 2): 999\\
Insertion not possible.\\
--- MENU ---\\
1. Insert Row\\
2. Delete Row\\
3. Insert Column\\
4. Delete Column\\
5. Display\\
6. Exit\\
Enter your choice: 3\\
Enter column position to insert (0 to 2): 2\\
Enter elements of new column:\\
999\\
888\\
777\\
Column inserted.\\
--- MENU ---\\
1. Insert Row\\
2. Delete Row\\
3. Insert Column\\
4. Delete Column\\
5. Display\\
6. Exit\\
Enter your choice: 5\\
Matrix:\\
11 33 999\\
77 99 888\\
11 33 777\\
--- MENU ---\\
1. Insert Row\\
2. Delete Row\\
3. Insert Column\\
4. Delete Column\\
5. Display\\
6. Exit\\
Enter your choice: 6\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
\end{tcolorbox}










\newpage
\section*{Experiment 3: Gauss-Jordan Method for Solving Linear Equations}





\subsection*{Code}
\begin{lstlisting}
#include <stdio.h> // Standard input-output header

#define SIZE 10 // Maximum size of the matrix

// Function to perform Gauss-Jordan elimination
void gaussJordan(float matrix[SIZE][SIZE], int n) {
    int i, j, k; // Loop counters
    float ratio; // Ratio used to eliminate elements

    // Loop through each pivot element
    for (i = 0; i < n; i++) {
        // Make the pivot element (diagonal) equal to 1
        float diag = matrix[i][i];
        if (diag == 0) { // Check if diagonal element is zero
            printf("Mathematical Error: Division by 0\n");
            return; // Cannot proceed if division by zero
        }

        // Divide the entire row by the diagonal element
        for (j = 0; j <= n; j++) {
            matrix[i][j] = matrix[i][j] / diag;
        }

        // Make other elements in the same column equal to 0
        for (k = 0; k < n; k++) {
            if (k != i) { // Skip the pivot row
                ratio = matrix[k][i]; // Get the ratio to make element zero
                for (j = 0; j <= n; j++) {
                    matrix[k][j] = matrix[k][j] - ratio * matrix[i][j];
                }
            }
        }
    }

    // Display the solutions
    printf("\nSolution:\n");
    for (i = 0; i < n; i++) {
        printf("x%d = %.3f\n", i + 1, matrix[i][n]);
    }
}

// Main function
int main() {
    float matrix[SIZE][SIZE]; // Matrix declaration
    int n, i, j; // Variables for number of variables, counters

    // Input number of variables
    printf("Enter number of variables: ");
    scanf("%d", &n);

    // Input augmented matrix coefficients
    printf("Enter augmented matrix coefficients (Ax = b):\n");
    for (i = 0; i < n; i++) { // For each row
        for (j = 0; j <= n; j++) { // For each column (including RHS)
            printf("matrix[%d][%d]: ", i, j); // Prompt for each element
            scanf("%f", &matrix[i][j]); // Read element
        }
    }

    // Call function to perform Gauss-Jordan elimination
    gaussJordan(matrix, n);

    return 0;
}
\end{lstlisting}








\newpage
\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 14:17:31 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 3.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
Enter number of variables: 3\\
Enter the augmented matrix (including RHS values):\\
2\\
1\\
-1\\
8\\
-3\\
-1\\
2\\
-11\\
-2\\
1\\
2\\
-3\\
\\
The solutions are:\\
x1 = 2.0000\\
x2 = 3.0000\\
x3 = -1.0000\\
\\
--- MENU ---\\
1. Solve another system\\
2. Exit\\
Enter your choice: 1\\
Enter number of variables: 2\\
Enter the augmented matrix (including RHS values):\\
1\\
2\\
3\\
4\\
\\
The solutions are:\\
x1 = -2.0000\\
x2 = 3.0000\\
\\
--- MENU ---\\
1. Solve another system\\
2. Exit\\
Enter your choice: 2\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}


\newpage
\section*{Experiment 4: Gauss Elimination Method}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>

#define SIZE 10

void gaussElimination(float matrix[SIZE][SIZE], int n) {
    int i, j, k;
    float ratio;
    float x[SIZE];

    // Forward Elimination
    for (i = 0; i < n - 1; i++) {
        if (matrix[i][i] == 0.0) {
            printf("Mathematical Error: Division by zero\n");
            return;
        }
        for (j = i + 1; j < n; j++) {
            ratio = matrix[j][i] / matrix[i][i];
            for (k = 0; k <= n; k++) {
                matrix[j][k] -= ratio * matrix[i][k];
            }
        }
    }

    // Back Substitution
    x[n - 1] = matrix[n - 1][n] / matrix[n - 1][n - 1];
    for (i = n - 2; i >= 0; i--) {
        x[i] = matrix[i][n];
        for (j = i + 1; j < n; j++) {
            x[i] -= matrix[i][j] * x[j];
        }
        x[i] = x[i] / matrix[i][i];
    }

    // Print Solution
    printf("\nSolution:\n");
    for (i = 0; i < n; i++) {
        printf("x%d = %.3f\n", i + 1, x[i]);
    }
}

int main() {
    float matrix[SIZE][SIZE];
    int n, i, j;

    printf("Enter number of variables: ");
    scanf("%d", &n);

    printf("Enter augmented matrix (Ax = b):\n");
    for (i = 0; i < n; i++) {
        for (j = 0; j <= n; j++) {
            printf("matrix[%d][%d]: ", i, j);
            scanf("%f", &matrix[i][j]);
        }
    }

    gaussElimination(matrix, n);

    return 0;
}
\end{lstlisting}

\newpage
\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 14:17:31 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 4.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
Enter number of equations: 3\\
Enter the augmented matrix (including RHS values):\\
2\\
3\\
1\\
1\\
1\\
2\\
3\\
2\\
1\\
9\\
\\
Performing forward elimination...\\
Matrix after forward elimination:\\
2.0000 \quad 3.0000 \quad 1.0000 \quad 1.0000\\
0.0000 \quad -0.5000 \quad 1.5000 \quad 0.5000\\
0.0000 \quad 0.0000 \quad -2.0000 \quad -1.0000\\
\\
Performing back substitution...\\
The solutions are:\\
x3 = 0.5000\\
x2 = 0.5000\\
x1 = 0.0000\\
\\
--- MENU ---\\
1. Solve another system\\
2. Exit\\
Enter your choice: 1\\
Enter number of equations: 2\\
Enter the augmented matrix (including RHS values):\\
3\\
2\\
1\\
2\\
5\\
\\
Performing forward elimination...\\
Matrix after forward elimination:\\
3.0000 \quad 2.0000 \quad 1.0000\\
0.0000 \quad 1.3333 \quad 1.6667\\
\\
Performing back substitution...\\
The solutions are:\\
x2 = 1.2500\\
x1 = 0.1667\\
\\
--- MENU ---\\
1. Solve another system\\
2. Exit\\
Enter your choice: 2\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}



\newpage
\section*{Experiment 5: Singly Linked List Operations (Insert, Delete by Value, Reverse, Display)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* head = NULL;

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// Insert a node at the end
void insert(int value) {
    struct Node* newNode = createNode(value);
    if (head == NULL) {
        head = newNode;
        return;
    }

    struct Node* temp = head;
    while (temp->next != NULL)
        temp = temp->next;

    temp->next = newNode;
}

// Delete node by value
void deleteByValue(int value) {
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node *temp = head, *prev = NULL;

    while (temp != NULL && temp->data != value) {
        prev = temp;
        temp = temp->next;
    }

    if (temp == NULL) {
        printf("Value not found\n");
        return;
    }

    if (prev == NULL) {
        head = head->next;
    } else {
        prev->next = temp->next;
    }

    free(temp);
    printf("Deleted %d\n", value);
}

// Reverse the linked list
void reverse() {
    struct Node *prev = NULL, *curr = head, *next = NULL;

    while (curr != NULL) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }

    head = prev;
    printf("List reversed.\n");
}

// Display the linked list
void display() {
    struct Node* temp = head;

    printf("Linked List: ");
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Main function with menu
int main() {
    int choice, value;

    do {
        printf("\n1. Insert\n2. Delete by value\n3. Reverse\n4. Display\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                insert(value);
                break;
            case 2:
                printf("Enter value to delete: ");
                scanf("%d", &value);
                deleteByValue(value);
                break;
            case 3:
                reverse();
                break;
            case 4:
                display();
                break;
        }

    } while (choice != 5);

    return 0;
}
\end{lstlisting}

\newpage

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 15:11:09 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 5.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display list\\
5. Exit\\
Enter your choice: 1\\
Enter value to insert at beginning: 10\\
Node inserted at beginning.\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display list\\
5. Exit\\
Enter your choice: 2\\
Enter value to insert at end: 20\\
Node inserted at end.\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display list\\
5. Exit\\
Enter your choice: 2\\
Enter value to insert at end: 30\\
Node inserted at end.\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display list\\
5. Exit\\
Enter your choice: 4\\
Linked List:\\
10\t20\t30\tNULL\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display list\\
5. Exit\\
Enter your choice: 3\\
Enter value to delete: 20\\
Node with value 20 deleted.\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display list\\
5. Exit\\
Enter your choice: 4\\
Linked List:\\
10\t30\tNULL\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display list\\
5. Exit\\
Enter your choice: 3\\
Enter value to delete: 100\\
Value not found in the list.\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display list\\
5. Exit\\
Enter your choice: 5\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}


\newpage
\section*{Experiment 6: Doubly Linked List Operations (Insert, Delete by Value, Reverse, Display)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define node
struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};

struct Node* head = NULL;

// Create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->prev = NULL;
    newNode->next = NULL;
    return newNode;
}

// Insert at end
void insert(int value) {
    struct Node* newNode = createNode(value);
    if (head == NULL) {
        head = newNode;
        return;
    }
    struct Node* temp = head;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
    newNode->prev = temp;
}

// Delete by value
void deleteByValue(int value) {
    struct Node* temp = head;

    while (temp != NULL && temp->data != value) {
        temp = temp->next;
    }

    if (temp == NULL) {
        printf("Value not found\n");
        return;
    }

    if (temp->prev != NULL)
        temp->prev->next = temp->next;
    else
        head = temp->next;

    if (temp->next != NULL)
        temp->next->prev = temp->prev;

    free(temp);
    printf("Deleted %d\n", value);
}

// Reverse the list
void reverse() {
    struct Node *curr = head, *temp = NULL;

    while (curr != NULL) {
        // Swap next and prev
        temp = curr->prev;
        curr->prev = curr->next;
        curr->next = temp;
        curr = curr->prev;
    }

    // After loop, temp points to the previous of last node
    if (temp != NULL)
        head = temp->prev;
}

// Display list
void display() {
    struct Node* temp = head;
    printf("Doubly Linked List: ");
    while (temp != NULL) {
        printf("%d <-> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

int main() {
    int choice, value;

    do {
        printf("\n1. Insert\n2. Delete by value\n3. Reverse\n4. Display\n5. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                insert(value);
                break;
            case 2:
                printf("Enter value to delete: ");
                scanf("%d", &value);
                deleteByValue(value);
                break;
            case 3:
                reverse();
                printf("List reversed.\n");
                break;
            case 4:
                display();
                break;
        }

    } while (choice != 5);

    return 0;
}
\end{lstlisting}



\newpage
\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 17:12:51 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 6.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display forward\\
5. Display backward\\
6. Exit\\
Enter your choice: 1\\
Enter value to insert at beginning: 50\\
Node inserted at beginning.\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display forward\\
5. Display backward\\
6. Exit\\
Enter your choice: 2\\
Enter value to insert at end: 100\\
Node inserted at end.\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display forward\\
5. Display backward\\
6. Exit\\
Enter your choice: 2\\
Enter value to insert at end: 150\\
Node inserted at end.\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display forward\\
5. Display backward\\
6. Exit\\
Enter your choice: 4\\
Doubly Linked List (forward):\\
50 \quad 100 \quad 150 \quad NULL\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display forward\\
5. Display backward\\
6. Exit\\
Enter your choice: 5\\
Doubly Linked List (backward):\\
150 \quad 100 \quad 50 \quad NULL\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display forward\\
5. Display backward\\
6. Exit\\
Enter your choice: 3\\
Enter value to delete: 100\\
Node with value 100 deleted.\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display forward\\
5. Display backward\\
6. Exit\\
Enter your choice: 4\\
Doubly Linked List (forward):\\
50 \quad 150 \quad NULL\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display forward\\
5. Display backward\\
6. Exit\\
Enter your choice: 3\\
Enter value to delete: 500\\
Value not found in the list.\\
\\
--- MENU ---\\
1. Insert at beginning\\
2. Insert at end\\
3. Delete by value\\
4. Display forward\\
5. Display backward\\
6. Exit\\
Enter your choice: 6\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}

\newpage
\section*{Experiment 7: Circular Singly Linked List Operations (Insert, Delete by Value, Reverse, Display)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* head = NULL;

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// Insert a node at the end
void insert(int value) {
    struct Node* newNode = createNode(value);
    if (head == NULL) {
        head = newNode;
        newNode->next = head;
        return;
    }

    struct Node* temp = head;
    while (temp->next != head)
        temp = temp->next;

    temp->next = newNode;
    newNode->next = head;
}

// Delete a node by value
void deleteByValue(int value) {
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node *temp = head, *prev = NULL;

    if (head->data == value) {
        if (head->next == head) {
            free(head);
            head = NULL;
            printf("Deleted %d\n", value);
            return;
        }

        struct Node* last = head;
        while (last->next != head)
            last = last->next;

        last->next = head->next;
        temp = head;
        head = head->next;
        free(temp);
        printf("Deleted %d\n", value);
        return;
    }

    do {
        prev = temp;
        temp = temp->next;
    } while (temp != head && temp->data != value);

    if (temp == head) {
        printf("Value not found\n");
        return;
    }

    prev->next = temp->next;
    free(temp);
    printf("Deleted %d\n", value);
}

// Reverse the circular linked list
void reverse() {
    if (head == NULL || head->next == head) {
        printf("List reversed.\n");
        return;
    }

    struct Node *prev = NULL, *curr = head, *next = NULL, *last = head;

    while (last->next != head)
        last = last->next;

    do {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    } while (curr != head);

    head->next = prev;
    head = prev;
    last->next = head;

    printf("List reversed.\n");
}

// Display the circular linked list
void display() {
    if (head == NULL) {
        printf("Circular Linked List is empty\n");
        return;
    }

    struct Node* temp = head;
    printf("Circular Linked List: ");
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("(head)\n");
}

// Main function with menu
int main() {
    int choice, value;

    do {
        printf("\n1. Insert\n2. Delete by value\n3. Reverse\n4. Display\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                insert(value);
                break;
            case 2:
                printf("Enter value to delete: ");
                scanf("%d", &value);
                deleteByValue(value);
                break;
            case 3:
                reverse();
                break;
            case 4:
                display();
                break;
        }

    } while (choice != 5);

    return 0;
}
\end{lstlisting}



\newpage

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 14:44:12 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 7.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to insert at end: 5\\
Node inserted at end.\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to insert at end: 10\\
Node inserted at end.\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to insert at end: 15\\
Node inserted at end.\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Circular Linked List elements:\\
5 \quad 10 \quad 15\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
Enter value to delete: 10\\
Node with value 10 deleted.\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Circular Linked List elements:\\
5 \quad 15\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
Enter value to delete: 100\\
Value not found in the list.\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display\\
4. Exit\\
Enter your choice: 4\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}

\newpage
\section*{Experiment 8: Circular Doubly Linked List Operations (Insert, Delete by Value, Reverse, Display)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

struct Node* head = NULL;

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    newNode->prev = NULL;
    return newNode;
}

// Insert a node at the end
void insert(int value) {
    struct Node* newNode = createNode(value);
    if (head == NULL) {
        head = newNode;
        newNode->next = head;
        newNode->prev = head;
        return;
    }

    struct Node* tail = head->prev;
    tail->next = newNode;
    newNode->prev = tail;
    newNode->next = head;
    head->prev = newNode;
}

// Delete a node by value
void deleteByValue(int value) {
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node* temp = head;

    do {
        if (temp->data == value) {
            if (temp->next == temp && temp->prev == temp) {
                free(temp);
                head = NULL;
                printf("Deleted %d\n", value);
                return;
            }

            temp->prev->next = temp->next;
            temp->next->prev = temp->prev;

            if (temp == head) {
                head = temp->next;
            }

            free(temp);
            printf("Deleted %d\n", value);
            return;
        }
        temp = temp->next;
    } while (temp != head);

    printf("Value not found\n");
}

// Reverse the doubly circular linked list
void reverse() {
    if (head == NULL || head->next == head) {
        printf("List reversed.\n");
        return;
    }

    struct Node *curr = head, *temp = NULL;

    do {
        temp = curr->prev;
        curr->prev = curr->next;
        curr->next = temp;
        curr = curr->prev;
    } while (curr != head);

    head = temp->prev;
    printf("List reversed.\n");
}

// Display the doubly circular linked list
void display() {
    if (head == NULL) {
        printf("Doubly Circular Linked List is empty\n");
        return;
    }

    struct Node* temp = head;
    printf("Doubly Circular Linked List: ");
    do {
        printf("%d <-> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("(head)\n");
}

// Main function with menu
int main() {
    int choice, value;

    do {
        printf("\n1. Insert\n2. Delete by value\n3. Reverse\n4. Display\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                insert(value);
                break;
            case 2:
                printf("Enter value to delete: ");
                scanf("%d", &value);
                deleteByValue(value);
                break;
            case 3:
                reverse();
                break;
            case 4:
                display();
                break;
        }

    } while (choice != 5);

    return 0;
}
\end{lstlisting}



\newpage

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 14:52:47 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 8.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display forward\\
4. Display backward\\
5. Exit\\
Enter your choice: 1\\
Enter value to insert at end: 25\\
Node inserted at end.\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display forward\\
4. Display backward\\
5. Exit\\
Enter your choice: 1\\
Enter value to insert at end: 50\\
Node inserted at end.\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display forward\\
4. Display backward\\
5. Exit\\
Enter your choice: 1\\
Enter value to insert at end: 75\\
Node inserted at end.\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display forward\\
4. Display backward\\
5. Exit\\
Enter your choice: 3\\
Circular Doubly Linked List (forward):\\
25 \quad 50 \quad 75\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display forward\\
4. Display backward\\
5. Exit\\
Enter your choice: 4\\
Circular Doubly Linked List (backward):\\
75 \quad 50 \quad 25\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display forward\\
4. Display backward\\
5. Exit\\
Enter your choice: 2\\
Enter value to delete: 50\\
Node with value 50 deleted.\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display forward\\
4. Display backward\\
5. Exit\\
Enter your choice: 3\\
Circular Doubly Linked List (forward):\\
25 \quad 75\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display forward\\
4. Display backward\\
5. Exit\\
Enter your choice: 2\\
Enter value to delete: 100\\
Value not found in the list.\\
\\
--- MENU ---\\
1. Insert at end\\
2. Delete by value\\
3. Display forward\\
4. Display backward\\
5. Exit\\
Enter your choice: 5\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}

\newpage
\section*{Experiment 9: Stack Implementation using Array}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#define MAX 100

int stack[MAX];
int top = -1;

// Function to push an element onto the stack
void push(int value) {
    if (top == MAX - 1) {
        printf("Stack Overflow! Cannot push %d\n", value);
        return;
    }
    stack[++top] = value;
    printf("Pushed %d onto the stack\n", value);
}

// Function to pop an element from the stack
void pop() {
    if (top == -1) {
        printf("Stack Underflow! Cannot pop\n");
        return;
    }
    printf("Popped %d from the stack\n", stack[top--]);
}

// Function to peek at the top element of the stack
void peek() {
    if (top == -1) {
        printf("Stack is empty\n");
        return;
    }
    printf("Top element is %d\n", stack[top]);
}

// Function to display the stack
void display() {
    if (top == -1) {
        printf("Stack is empty\n");
        return;
    }
    printf("Stack elements: ");
    for (int i = top; i >= 0; i--) {
        printf("%d ", stack[i]);
    }
    printf("\n");
}

// Main function with menu
int main() {
    int choice, value;

    do {
        printf("\n1. Push\n2. Pop\n3. Peek\n4. Display\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to push: ");
                scanf("%d", &value);
                push(value);
                break;
            case 2:
                pop();
                break;
            case 3:
                peek();
                break;
            case 4:
                display();
                break;
            case 5:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice, please try again\n");
        }
    } while (choice != 5);

    return 0;
}
\end{lstlisting}

\newpage

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 15:01:23 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 9.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to push: 10\\
10 pushed onto stack.\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to push: 20\\
20 pushed onto stack.\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to push: 30\\
30 pushed onto stack.\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Stack elements:\\
30\\
20\\
10\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
30 popped from stack.\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Stack elements:\\
20\\
10\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
20 popped from stack.\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
10 popped from stack.\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
Stack Underflow! Cannot pop.\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 4\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}

\newpage
\section*{Experiment 10: Stack Implementation using Linked List}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* top = NULL;

// Function to push an element onto the stack
void push(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Stack Overflow! Cannot push %d\n", value);
        return;
    }
    newNode->data = value;
    newNode->next = top;
    top = newNode;
    printf("Pushed %d onto the stack\n", value);
}

// Function to pop an element from the stack
void pop() {
    if (top == NULL) {
        printf("Stack Underflow! Cannot pop\n");
        return;
    }
    struct Node* temp = top;
    printf("Popped %d from the stack\n", top->data);
    top = top->next;
    free(temp);
}

// Function to peek at the top element of the stack
void peek() {
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    }
    printf("Top element is %d\n", top->data);
}

// Function to display the stack
void display() {
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    }
    struct Node* temp = top;
    printf("Stack elements: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

// Main function with menu
int main() {
    int choice, value;

    do {
        printf("\n1. Push\n2. Pop\n3. Peek\n4. Display\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to push: ");
                scanf("%d", &value);
                push(value);
                break;
            case 2:
                pop();
                break;
            case 3:
                peek();
                break;
            case 4:
                display();
                break;
            case 5:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice, please try again\n");
        }
    } while (choice != 5);

    return 0;
}
\end{lstlisting}

\newpage
\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 15:09:18 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 10.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to push: 100\\
100 pushed onto stack.\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to push: 200\\
200 pushed onto stack.\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Stack elements:\\
200\\
100\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
200 popped from stack.\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Stack elements:\\
100\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
100 popped from stack.\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
Stack Underflow! Cannot pop.\\
\\
--- MENU ---\\
1. Push\\
2. Pop\\
3. Display\\
4. Exit\\
Enter your choice: 4\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}


\newpage
\section*{Experiment 11: Queue using Array}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#define MAX 100

int queue[MAX];
int front = -1, rear = -1;

void enqueue(int value) {
    if (rear == MAX - 1) {
        printf("Queue Overflow! Cannot enqueue %d\n", value);
        return;
    }
    if (front == -1) {
        front = 0;
    }
    queue[++rear] = value;
    printf("Enqueued %d into the queue\n", value);
}

void dequeue() {
    if (front == -1 || front > rear) {
        printf("Queue Underflow! Cannot dequeue\n");
        return;
    }
    printf("Dequeued %d from the queue\n", queue[front++]);
    if (front > rear) {
        front = rear = -1;
    }
}

void display() {
    if (front == -1 || front > rear) {
        printf("Queue is empty\n");
        return;
    }
    printf("Queue elements: ");
    for (int i = front; i <= rear; i++) {
        printf("%d ", queue[i]);
    }
    printf("\n");
}

int main() {
    int choice, value;

    do {
        printf("\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to enqueue: ");
                scanf("%d", &value);
                enqueue(value);
                break;
            case 2:
                dequeue();
                break;
            case 3:
                display();
                break;
            case 4:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice, please try again\n");
        }
    } while (choice != 4);

    return 0;
}
\end{lstlisting}

\newpage
\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 15:17:02 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 11.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 5\\
5 enqueued into queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 15\\
15 enqueued into queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 25\\
25 enqueued into queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Queue elements:\\
5 \quad 15 \quad 25\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
5 dequeued from queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Queue elements:\\
15 \quad 25\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
15 dequeued from queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
25 dequeued from queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
Queue Underflow! Cannot dequeue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 4\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}


\newpage
\section*{Experiment 12: Queue using Linked List}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* front = NULL;
struct Node* rear = NULL;

void enqueue(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Memory allocation failed! Cannot enqueue %d\n", value);
        return;
    }
    newNode->data = value;
    newNode->next = NULL;

    if (rear == NULL) {
        front = rear = newNode;
        printf("Enqueued %d into the queue\n", value);
        return;
    }

    rear->next = newNode;
    rear = newNode;
    printf("Enqueued %d into the queue\n", value);
}

void dequeue() {
    if (front == NULL) {
        printf("Queue Underflow! Cannot dequeue\n");
        return;
    }

    struct Node* temp = front;
    printf("Dequeued %d from the queue\n", front->data);
    front = front->next;

    if (front == NULL) {
        rear = NULL;
    }

    free(temp);
}

void display() {
    if (front == NULL) {
        printf("Queue is empty\n");
        return;
    }

    struct Node* temp = front;
    printf("Queue elements: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    int choice, value;

    do {
        printf("\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to enqueue: ");
                scanf("%d", &value);
                enqueue(value);
                break;
            case 2:
                dequeue();
                break;
            case 3:
                display();
                break;
            case 4:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice, please try again\n");
        }
    } while (choice != 4);

    return 0;
}
\end{lstlisting}

\newpage

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 15:23:44 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 12.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 50\\
50 enqueued into queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 100\\
100 enqueued into queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Queue elements:\\
50 \quad 100\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
50 dequeued from queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Queue elements:\\
100\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
100 dequeued from queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
Queue Underflow! Cannot dequeue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 4\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}

\newpage
\section*{Experiment 13: Circular Queue using Array}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#define MAX 5

int queue[MAX];
int front = -1, rear = -1;

void enqueue(int value) {
    if ((rear + 1) % MAX == front) {
        printf("Queue Overflow! Cannot enqueue %d\n", value);
        return;
    }
    if (front == -1) {
        front = 0;
    }
    rear = (rear + 1) % MAX;
    queue[rear] = value;
    printf("Enqueued %d into the queue\n", value);
}

void dequeue() {
    if (front == -1) {
        printf("Queue Underflow! Cannot dequeue\n");
        return;
    }
    printf("Dequeued %d from the queue\n", queue[front]);
    if (front == rear) {
        front = rear = -1;
    } else {
        front = (front + 1) % MAX;
    }
}

void display() {
    if (front == -1) {
        printf("Queue is empty\n");
        return;
    }
    printf("Queue elements: ");
    int i = front;
    while (1) {
        printf("%d ", queue[i]);
        if (i == rear) break;
        i = (i + 1) % MAX;
    }
    printf("\n");
}

int main() {
    int choice, value;

    do {
        printf("\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to enqueue: ");
                scanf("%d", &value);
                enqueue(value);
                break;
            case 2:
                dequeue();
                break;
            case 3:
                display();
                break;
            case 4:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice, please try again\n");
        }
    } while (choice != 4);

    return 0;
}
\end{lstlisting}

\newapge

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 15:31:06 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 13.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 10\\
10 enqueued into circular queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 20\\
20 enqueued into circular queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 30\\
30 enqueued into circular queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Circular Queue elements:\\
10 \quad 20 \quad 30\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
10 dequeued from circular queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Circular Queue elements:\\
20 \quad 30\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 40\\
40 enqueued into circular queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Circular Queue elements:\\
20 \quad 30 \quad 40\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 4\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}

\newpage
\section*{Experiment 14: Circular Queue using Linked List}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* front = NULL;
struct Node* rear = NULL;

void enqueue(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Memory allocation failed! Cannot enqueue %d\n", value);
        return;
    }
    newNode->data = value;
    newNode->next = NULL;

    if (front == NULL) {
        front = rear = newNode;
        rear->next = front;
        printf("Enqueued %d into the queue\n", value);
        return;
    }

    rear->next = newNode;
    rear = newNode;
    rear->next = front;
    printf("Enqueued %d into the queue\n", value);
}

void dequeue() {
    if (front == NULL) {
        printf("Queue Underflow! Cannot dequeue\n");
        return;
    }

    struct Node* temp = front;
    if (front == rear) {
        front = rear = NULL;
    } else {
        front = front->next;
        rear->next = front;
    }

    printf("Dequeued %d from the queue\n", temp->data);
    free(temp);
}

void display() {
    if (front == NULL) {
        printf("Queue is empty\n");
        return;
    }

    struct Node* temp = front;
    printf("Queue elements: ");
    do {
        printf("%d ", temp->data);
        temp = temp->next;
    } while (temp != front);
    printf("\n");
}

int main() {
    int choice, value;

    do {
        printf("\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to enqueue: ");
                scanf("%d", &value);
                enqueue(value);
                break;
            case 2:
                dequeue();
                break;
            case 3:
                display();
                break;
            case 4:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice, please try again\n");
        }
    } while (choice != 4);

    return 0;
}
\end{lstlisting}

\subsection*{Output}
\newpage
\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 15:38:22 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 14.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 11\\
11 enqueued into circular queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 1\\
Enter value to enqueue: 22\\
22 enqueued into circular queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Circular Queue elements:\\
11 \quad 22\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
11 dequeued from circular queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 3\\
Circular Queue elements:\\
22\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
22 dequeued from circular queue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 2\\
Queue Underflow! Cannot dequeue.\\
\\
--- MENU ---\\
1. Enqueue\\
2. Dequeue\\
3. Display\\
4. Exit\\
Enter your choice: 4\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}


\newpage
\section*{Experiment 15: Binary Tree Operations (Creation, Traversals, Height)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a tree node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to build the binary tree dynamically
struct Node* buildTree() {
    int value;
    printf("Enter data (-1 for no node): ");
    scanf("%d", &value);

    if (value == -1) {
        return NULL;
    }

    struct Node* newNode = createNode(value);
    printf("Enter left child of %d:\n", value);
    newNode->left = buildTree();
    printf("Enter right child of %d:\n", value);
    newNode->right = buildTree();

    return newNode;
}

// Inorder Traversal (Left, Root, Right)
void inorderTraversal(struct Node* root) {
    if (root == NULL) return;
    inorderTraversal(root->left);
    printf("%d ", root->data);
    inorderTraversal(root->right);
}

// Preorder Traversal (Root, Left, Right)
void preorderTraversal(struct Node* root) {
    if (root == NULL) return;
    printf("%d ", root->data);
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}

// Postorder Traversal (Left, Right, Root)
void postorderTraversal(struct Node* root) {
    if (root == NULL) return;
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    printf("%d ", root->data);
}

// Function to find the height of the binary tree
int findHeight(struct Node* root) {
    if (root == NULL) return -1;
    int leftHeight = findHeight(root->left);
    int rightHeight = findHeight(root->right);
    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;
}

int main() {
    printf("Build the binary tree:\n");
    struct Node* root = buildTree();

    printf("\nInorder Traversal: ");
    inorderTraversal(root);
    printf("\n");

    printf("Preorder Traversal: ");
    preorderTraversal(root);
    printf("\n");

    printf("Postorder Traversal: ");
    postorderTraversal(root);
    printf("\n");

    printf("Height of the binary tree: %d\n", findHeight(root));

    return 0;
}
\end{lstlisting}

\newpage
\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 15:46:55 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 15.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 1\\
Enter value to insert: 50\\
Node inserted.\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 1\\
Enter value to insert: 30\\
Node inserted.\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 1\\
Enter value to insert: 70\\
Node inserted.\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 2\\
Inorder Traversal:\\
30 \quad 50 \quad 70\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 3\\
Preorder Traversal:\\
50 \quad 30 \quad 70\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 4\\
Postorder Traversal:\\
30 \quad 70 \quad 50\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 5\\
Height of the binary tree: 1\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 6\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}


\newpage
\section*{Experiment 16: Implementation of Binary Search Tree (BST) and Operations}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

// Define the node structure
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node in BST
struct Node* insert(struct Node* root, int value) {
    if (root == NULL)
        return createNode(value);

    if (value < root->data)
        root->left = insert(root->left, value);
    else if (value > root->data)
        root->right = insert(root->right, value);

    return root;
}

// Inorder traversal (LNR)
void inorder(struct Node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

// Preorder traversal (NLR)
void preorder(struct Node* root) {
    if (root != NULL) {
        printf("%d ", root->data);
        preorder(root->left);
        preorder(root->right);
    }
}

// Postorder traversal (LRN)
void postorder(struct Node* root) {
    if (root != NULL) {
        postorder(root->left);
        postorder(root->right);
        printf("%d ", root->data);
    }
}

// Function to calculate height of BST
int height(struct Node* root) {
    if (root == NULL)
        return -1;

    int leftHeight = height(root->left);
    int rightHeight = height(root->right);

    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;
}

int main() {
    struct Node* root = NULL;
    int choice, value;

    do {
        printf("\n1. Insert\n2. Inorder\n3. Preorder\n4. Postorder\n5. Height\n6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                root = insert(root, value);
                break;
            case 2:
                printf("Inorder Traversal: ");
                inorder(root);
                printf("\n");
                break;
            case 3:
                printf("Preorder Traversal: ");
                preorder(root);
                printf("\n");
                break;
            case 4:
                printf("Postorder Traversal: ");
                postorder(root);
                printf("\n");
                break;
            case 5:
                printf("Height of tree: %d\n", height(root));
                break;
            case 6:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice\n");
        }

    } while (choice != 6);

    return 0;
}
\end{lstlisting}

\newpage
\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 15:55:14 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 16.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 1\\
Enter value to insert: 40\\
Node inserted.\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 1\\
Enter value to insert: 20\\
Node inserted.\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 1\\
Enter value to insert: 60\\
Node inserted.\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 1\\
Enter value to insert: 10\\
Node inserted.\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 2\\
Inorder Traversal:\\
10 \quad 20 \quad 40 \quad 60\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 3\\
Preorder Traversal:\\
40 \quad 20 \quad 10 \quad 60\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 4\\
Postorder Traversal:\\
10 \quad 20 \quad 60 \quad 40\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 5\\
Height of the binary search tree: 2\\
\\
--- MENU ---\\
1. Insert\\
2. Inorder Traversal\\
3. Preorder Traversal\\
4. Postorder Traversal\\
5. Find Height\\
6. Exit\\
Enter your choice: 6\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}


\newpage
\section*{Experiment 17: AVL Tree Operations (Insert, Delete, Search, Traversal, Height)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
    int height;
};

int getHeight(struct Node* node) {
    return (node == NULL) ? -1 : node->height;
}

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = newNode->right = NULL;
    newNode->height = 0;
    return newNode;
}

int getBalanceFactor(struct Node* node) {
    return (node == NULL) ? 0 : getHeight(node->left) - getHeight(node->right);
}

struct Node* rightRotate(struct Node* y) {
    struct Node* x = y->left;
    struct Node* T2 = x->right;

    x->right = y;
    y->left = T2;

    y->height = 1 + (getHeight(y->left) > getHeight(y->right)
                    ? getHeight(y->left) : getHeight(y->right));
    x->height = 1 + (getHeight(x->left) > getHeight(x->right)
                    ? getHeight(x->left) : getHeight(x->right));
    return x;
}

struct Node* leftRotate(struct Node* x) {
    struct Node* y = x->right;
    struct Node* T2 = y->left;

    y->left = x;
    x->right = T2;

    x->height = 1 + (getHeight(x->left) > getHeight(x->right)
                    ? getHeight(x->left) : getHeight(x->right));
    y->height = 1 + (getHeight(y->left) > getHeight(y->right)
                    ? getHeight(y->left) : getHeight(y->right));
    return y;
}

struct Node* insert(struct Node* node, int value) {
    if (node == NULL) return createNode(value);

    if (value < node->data) node->left = insert(node->left, value);
    else if (value > node->data) node->right = insert(node->right, value);
    else return node;

    node->height = 1 + (getHeight(node->left) > getHeight(node->right)
                        ? getHeight(node->left) : getHeight(node->right));

    int balance = getBalanceFactor(node);

    if (balance > 1 && value < node->left->data) return rightRotate(node);
    if (balance < -1 && value > node->right->data) return leftRotate(node);
    if (balance > 1 && value > node->left->data) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }
    if (balance < -1 && value < node->right->data) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }

    return node;
}

struct Node* findMin(struct Node* node) {
    while (node->left != NULL) node = node->left;
    return node;
}

struct Node* deleteNode(struct Node* root, int value) {
    if (root == NULL) return root;

    if (value < root->data) root->left = deleteNode(root->left, value);
    else if (value > root->data) root->right = deleteNode(root->right, value);
    else {
        if (!root->left || !root->right) {
            struct Node* temp = root->left ? root->left : root->right;
            if (temp == NULL) {
                temp = root;
                root = NULL;
            } else *root = *temp;
            free(temp);
        } else {
            struct Node* temp = findMin(root->right);
            root->data = temp->data;
            root->right = deleteNode(root->right, temp->data);
        }
    }

    if (root == NULL) return root;

    root->height = 1 + (getHeight(root->left) > getHeight(root->right)
                        ? getHeight(root->left) : getHeight(root->right));

    int balance = getBalanceFactor(root);

    if (balance > 1 && getBalanceFactor(root->left) >= 0) return rightRotate(root);
    if (balance > 1 && getBalanceFactor(root->left) < 0) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }
    if (balance < -1 && getBalanceFactor(root->right) <= 0) return leftRotate(root);
    if (balance < -1 && getBalanceFactor(root->right) > 0) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }

    return root;
}

int search(struct Node* root, int value) {
    if (root == NULL) return 0;
    if (value == root->data) return 1;
    return (value < root->data) ? search(root->left, value) : search(root->right, value);
}

void inorderTraversal(struct Node* root) {
    if (root == NULL) return;
    inorderTraversal(root->left);
    printf("%d ", root->data);
    inorderTraversal(root->right);
}

int main() {
    struct Node* root = NULL;
    int choice, value;

    do {
        printf("\n1. Insert\n2. Delete\n3. Search\n4. Inorder Traversal\n5. Height of Tree\n6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                root = insert(root, value);
                break;
            case 2:
                printf("Enter value to delete: ");
                scanf("%d", &value);
                root = deleteNode(root, value);
                break;
            case 3:
                printf("Enter value to search: ");
                scanf("%d", &value);
                if (search(root, value))
                    printf("Value found in the tree\n");
                else
                    printf("Value not found in the tree\n");
                break;
            case 4:
                printf("Inorder Traversal: ");
                inorderTraversal(root);
                printf("\n");
                break;
            case 5:
                printf("Height of the tree: %d\n", getHeight(root));
                break;
            case 6:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice, please try again\n");
        }
    } while (choice != 6);

    return 0;
}
\end{lstlisting}
\newpage
\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 16:04:32 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 17.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Inorder Traversal\\
5. Preorder Traversal\\
6. Postorder Traversal\\
7. Find Height\\
8. Exit\\
Enter your choice: 1\\
Enter value to insert: 30\\
Node inserted and tree balanced.\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Inorder Traversal\\
5. Preorder Traversal\\
6. Postorder Traversal\\
7. Find Height\\
8. Exit\\
Enter your choice: 1\\
Enter value to insert: 20\\
Node inserted and tree balanced.\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Inorder Traversal\\
5. Preorder Traversal\\
6. Postorder Traversal\\
7. Find Height\\
8. Exit\\
Enter your choice: 1\\
Enter value to insert: 40\\
Node inserted and tree balanced.\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Inorder Traversal\\
5. Preorder Traversal\\
6. Postorder Traversal\\
7. Find Height\\
8. Exit\\
Enter your choice: 4\\
Inorder Traversal:\\
20 \quad 30 \quad 40\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Inorder Traversal\\
5. Preorder Traversal\\
6. Postorder Traversal\\
7. Find Height\\
8. Exit\\
Enter your choice: 5\\
Preorder Traversal:\\
30 \quad 20 \quad 40\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Inorder Traversal\\
5. Preorder Traversal\\
6. Postorder Traversal\\
7. Find Height\\
8. Exit\\
Enter your choice: 3\\
Enter value to search: 40\\
Value 40 found in AVL Tree.\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Inorder Traversal\\
5. Preorder Traversal\\
6. Postorder Traversal\\
7. Find Height\\
8. Exit\\
Enter your choice: 2\\
Enter value to delete: 20\\
Node 20 deleted and tree balanced.\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Inorder Traversal\\
5. Preorder Traversal\\
6. Postorder Traversal\\
7. Find Height\\
8. Exit\\
Enter your choice: 4\\
Inorder Traversal:\\
30 \quad 40\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Inorder Traversal\\
5. Preorder Traversal\\
6. Postorder Traversal\\
7. Find Height\\
8. Exit\\
Enter your choice: 7\\
Height of the AVL Tree: 1\\
\\
--- MENU ---\\
1. Insert\\
2. Delete\\
3. Search\\
4. Inorder Traversal\\
5. Preorder Traversal\\
6. Postorder Traversal\\
7. Find Height\\
8. Exit\\
Enter your choice: 8\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}



\newpage
\section*{Experiment 18: Implementation of Various Sorting Algorithms (Bubble, Insertion, Selection, Quick Sort)}

\subsection*{Code}
\begin{lstlisting}
#include <stdio.h>

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++)
        for (int j = 0; j < n - i - 1; j++)
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
}

void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i], j = i - 1;
        while (j >= 0 && arr[j] > key)
            arr[j + 1] = arr[j--];
        arr[j + 1] = key;
    }
}

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;
        for (int j = i + 1; j < n; j++)
            if (arr[j] < arr[minIdx])
                minIdx = j;
        int temp = arr[minIdx];
        arr[minIdx] = arr[i];
        arr[i] = temp;
    }
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high], i = low - 1;
    for (int j = low; j <= high - 1; j++)
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return i + 1;
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

void display(int arr[], int n) {
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int arr[100], n, choice;

    printf("Enter number of elements: ");
    scanf("%d", &n);
    printf("Enter %d elements: ", n);
    for (int i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    do {
        printf("\n1. Bubble Sort\n2. Insertion Sort\n3. Selection Sort\n4. Quick Sort\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        int temp[100];
        for (int i = 0; i < n; i++)
            temp[i] = arr[i];

        switch (choice) {
            case 1:
                bubbleSort(temp, n);
                printf("Sorted using Bubble Sort: ");
                display(temp, n);
                break;
            case 2:
                insertionSort(temp, n);
                printf("Sorted using Insertion Sort: ");
                display(temp, n);
                break;
            case 3:
                selectionSort(temp, n);
                printf("Sorted using Selection Sort: ");
                display(temp, n);
                break;
            case 4:
                quickSort(temp, 0, n - 1);
                printf("Sorted using Quick Sort: ");
                display(temp, n);
                break;
            case 5:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice\n");
        }
    } while (choice != 5);

    return 0;
}
\end{lstlisting}
\newpage

\subsection*{Output}
\begin{tcolorbox}[terminalstyle, title=Sample Output]
\texttt{
Last login: Sat Apr 26 16:13:07 on ttys006\\
(base) ankit@Ankits-MacBook-Pro lab programs \% gcc 18.c -o out\\
(base) ankit@Ankits-MacBook-Pro lab programs \% ./out\\
Enter number of elements: 5\\
Enter array elements:\\
29\\
10\\
14\\
37\\
13\\
\\
--- MENU ---\\
1. Bubble Sort\\
2. Insertion Sort\\
3. Selection Sort\\
4. Quick Sort\\
5. Exit\\
Enter your choice: 1\\
Array after Bubble Sort:\\
10 \quad 13 \quad 14 \quad 29 \quad 37\\
\\
--- MENU ---\\
1. Bubble Sort\\
2. Insertion Sort\\
3. Selection Sort\\
4. Quick Sort\\
5. Exit\\
Enter your choice: 2\\
Enter array elements again for Insertion Sort:\\
29\\
10\\
14\\
37\\
13\\
Array after Insertion Sort:\\
10 \quad 13 \quad 14 \quad 29 \quad 37\\
\\
--- MENU ---\\
1. Bubble Sort\\
2. Insertion Sort\\
3. Selection Sort\\
4. Quick Sort\\
5. Exit\\
Enter your choice: 3\\
Enter array elements again for Selection Sort:\\
29\\
10\\
14\\
37\\
13\\
Array after Selection Sort:\\
10 \quad 13 \quad 14 \quad 29 \quad 37\\
\\
--- MENU ---\\
1. Bubble Sort\\
2. Insertion Sort\\
3. Selection Sort\\
4. Quick Sort\\
5. Exit\\
Enter your choice: 4\\
Enter array elements again for Quick Sort:\\
29\\
10\\
14\\
37\\
13\\
Array after Quick Sort:\\
10 \quad 13 \quad 14 \quad 29 \quad 37\\
\\
--- MENU ---\\
1. Bubble Sort\\
2. Insertion Sort\\
3. Selection Sort\\
4. Quick Sort\\
5. Exit\\
Enter your choice: 5\\
Exiting...\\
(base) ankit@Ankits-MacBook-Pro lab programs \%
}
\end{tcolorbox}

\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage
\newpage














\end{document}